# 36 - è¯­ä¹‰åˆ†å‰²

### ğŸ¦ æœ¬èŠ‚è¯¾ç¨‹è§†é¢‘åœ°å€ ğŸ‘‰[![Bilibil](	https://i1.hdslb.com/bfs/archive/01b1dc12575928c5026b4b124c134388d9bed2eb.jpg@640w_400h_100Q_1c.webp)](https://www.bilibili.com/video/BV1BK4y1M7Rd)
## è¯­ä¹‰åˆ†å‰²ï¼ˆsemantic segmentationï¼‰

- è¯­ä¹‰åˆ†å‰²å°†å›¾ç‰‡ä¸­çš„åƒç´ åˆ†ç±»åˆ°å¯¹åº”çš„ç±»åˆ«
  - é”šæ¡†å¤ªç³™äº†
  - ç²¾ç»†åˆ°åƒç´ çš„å½’å±çš„labels

**åº”ç”¨ï¼šè·¯é¢åˆ†å‰²**

![](\Images/semantics_segmentation.gif)

**åº”ç”¨:èƒŒæ™¯è™šåŒ–**

![](/Images/images.png)

**VSå®ä¾‹åˆ†å‰²(Instance Segmentation)**

- è¯­ä¹‰åˆ†å‰²åªé’ˆå¯¹ç±»
- å®ä¾‹åˆ†å‰²é’ˆå¯¹æ¯ä¸€ä¸ªç±»çš„å®ä¾‹

![](\Images/ä¸‹è¼‰.png)

**ä»£ç å®ç°**

<font color=red> æ•°æ®é›†å› ä¸ºå¤ªå¤§è¿˜æ²¡æœ‰ä¸‹è½½æˆåŠŸï¼Œç­‰æœ‰æ—¶é—´ä¸‹è½½å¥½äº†ï¼Œå†è·‘ä¸€éæœ€å¥½</font>

**ä¸‹è½½/è¯»æ•°æ®é›†**

```
%matplotlib inline
import os
import torch
import torchvision
from d2l import torch as d2l


d2l.DATA_HUB['voc2012'] = (d2l.DATA_URL + 'VOCtrainval_11-May-2012.tar',
                           '4e443f8a2eca6b1dac8a6c57641b67dd40621a49')

voc_dir = d2l.download_extract('voc2012', 'VOCdevkit/VOC2012')

#å°†æ‰€æœ‰çš„å›¾ç‰‡å’Œæ ‡ç­¾è¯»å…¥å†…å­˜
def read_voc_images(voc_dir, is_train=True):
    """è¯»å–æ‰€æœ‰VOCå›¾åƒå¹¶æ ‡æ³¨"""
    txt_fname = os.path.join(voc_dir, 'ImageSets', 'Segmentation',
                             'train.txt' if is_train else 'val.txt')
    #train.txtå’Œval.txtåˆ†åˆ«æ˜¯æŒ‡å¯¼è®­ç»ƒé›†å’ŒéªŒè¯é›†çš„æ–‡ä»¶
    mode = torchvision.io.image.ImageReadMode.RGB
    with open(txt_fname, 'r') as f:
        images = f.read().split()
        #å›¾ç‰‡åç§°
    features, labels = [], []
    for i, fname in enumerate(images):
        features.append(torchvision.io.read_image(os.path.join(
            voc_dir, 'JPEGImages', f'{fname}.jpg')))
        #è¯»å–å±äºè®­ç»ƒ/éªŒè¯é›†çš„å›¾ç‰‡
        labels.append(torchvision.io.read_image(os.path.join(
            voc_dir, 'SegmentationClass' ,f'{fname}.png'), mode))
        #è¯­ä¹‰åˆ†å‰²çš„labelsä¹Ÿæ˜¯å›¾ç‰‡é‡Œçš„æ¯ä¸€ä¸ªåƒç´ ï¼Œpngæ ¼å¼æ²¡æœ‰å‹ç¼©è¿‡å›¾ç‰‡
        #æˆ–è€…è¯´æ˜¯æ¯ä¸ªåƒç´ çš„å€¼
        #è®­ç»ƒå‡ºåƒç´ çš„å€¼ä¸å®é™…å€¼å¯¹æ¯”ï¼Œä½œä¸ºæŸå¤±å¹¶æ›´æ–°æ¢¯åº¦
    return features, labels

train_features, train_labels = read_voc_images(voc_dir, True)

n = 5
imgs = train_features[0:n] + train_labels[0:n]
imgs = [img.permute(1,2,0) for img in imgs]#æ›´æ”¹CHWä¸ºHWCï¼Œåˆ©äºæ˜¾ç¤ºå›¾ç‰‡
d2l.show_images(imgs, 2, n);
#æ¯ä¸€ä¸ªç±»æœ‰ä¸€ä¸ªå¯¹åº”çš„pixelçš„RGBå€¼
#é»‘èƒŒæ™¯ã€ç™½è¾¹æ¡†
#ç±»å‹ä»¥çº¢ã€ç»¿ã€è“åˆ†ç±»
```
**å»ºç«‹RGBæ˜ å°„**

```
#æ¯ä¸ªæ ‡å·ä¸pixelé¢œè‰²çš„æ˜ å°„
VOC_COLORMAP = [[0, 0, 0], [128, 0, 0], [0, 128, 0], [128, 128, 0],
                [0, 0, 128], [128, 0, 128], [0, 128, 128], [128, 128, 128],
                [64, 0, 0], [192, 0, 0], [64, 128, 0], [192, 128, 0],
                [64, 0, 128], [192, 0, 128], [64, 128, 128], [192, 128, 128],
                [0, 64, 0], [128, 64, 0], [0, 192, 0], [128, 192, 0],
                [0, 64, 128]]

VOC_CLASSES = ['background', 'aeroplane', 'bicycle', 'bird', 'boat',
               'bottle', 'bus', 'car', 'cat', 'chair', 'cow',
               'diningtable', 'dog', 'horse', 'motorbike', 'person',
               'potted plant', 'sheep', 'sofa', 'train', 'tv/monitor']

#æ„å»ºä»RGBåˆ°VOCç±»åˆ«ç´¢å¼•çš„æ˜ å°„
def voc_colormap2label():
    colormap2label = torch.zeros(256 ** 3, dtype=torch.long)
    #å…¨é›¶å‘é‡ï¼Œä»£è¡¨RGBçš„é¢œè‰²256*256*256ç§
    for i, colormap in enumerate(VOC_COLORMAP):
        colormap2label[
            (colormap[0] * 256 + colormap[1]) * 256 + colormap[2]] = i
        #ç›¸å½“äºæŠŠRGBç»è¿‡æ¢ç®—çš„å€¼å¤„å¼ é‡çš„ç´¢å¼•ä¸ä¸€ä¸ªæ ‡é‡ï¼ˆä¹Ÿå°±æ˜¯ç‰©ä½“çš„ç±»åˆ«ï¼‰ä¸€ä¸€å¯¹åº”
        #æœ€å¤§ç´¢å¼•å¤„255*256**2+255*256+255=256**3
        #è¿™æ ·çš„ç®—æ³•é¿å…å‡ºç°é‡å¤
    return colormap2label

def voc_label_indices(colormap, colormap2label):
    #colormap2labelæ„æ€æ˜¯ä½¿ç”¨æ—¶æŠŠè¯¥å‡½æ•°ä½œä¸ºå‚æ•°ä¼ å…¥ï¼Œä½†è¿™é‡Œå˜é‡çš„ä½ç½®å¹¶ä¸æŒ‡ä»£å‡½æ•°æœ¬èº«
    colormap = colormap.permute(1, 2, 0).numpy().astype('int32')
    idx = ((colormap[:, :, 0] * 256 + colormap[:, :, 1]) * 256
           + colormap[:, :, 2])
    #ç›¸å½“äºæŠŠæ¯ä¸ªå›¾ç‰‡ï¼Œh*wä¸ªåƒç´ ä¸€æ¬¡æ€§æ±‚RGBmapï¼Œç„¶åæ”¾å›ä¸€ä¸ªç´¢å¼•çš„çŸ©é˜µ
    return colormap2label[idx]
    #å†æ ¹æ®è¿™ä¸ªçŸ©é˜µçš„ç´¢å¼•ï¼Œæ‰¾åˆ°æ¯ä¸ªåƒç´ çš„ç±»åˆ«(classes)
    #å¦‚æœä¼ å‚æ²¡æœ‰colormap2labelï¼Œè¿™é‡Œå°±è¦return colormap2label()[idx]
    #numpyçš„çŸ©é˜µå¯ä»¥ä½œä¸ºç´¢å¼•ï¼Œé»˜è®¤æ˜¯ä»æœ€å¤–çš„ç»´åº¦å¼€å§‹ç´¢å¼•

y = voc_label_indices(train_labels[0], voc_colormap2label())
#è¿™é‡Œæ˜¯voc_colormap2label()ï¼Œè¦æŠŠè¯¥å‡½æ•°çš„è¿”å›å€¼å‘é‡colormap2labelä½œä¸ºå‚æ•°ä¼ å…¥
y[105:115, 130:140], VOC_CLASSES[1]
```

**åŸºäºå‰ªè£çš„å›¾åƒå¢å¹¿**

```
#å›¾ç‰‡å¢å¹¿
#å›¾ç‰‡å‰ªè£ä¹‹åï¼Œæ ‡å·ä¹‹ç±»çš„ä¹Ÿä¼šå˜åŒ–ï¼Œæ‰€ä»¥è¦ä¸€ä¸€å¯¹åº”
#å¯¹å›¾ç‰‡ä¸èƒ½resizeï¼Œåªèƒ½crop
#resizeç›¸å½“äºæ‹‰ä¼¸å’Œæ”¾ç¼©ï¼Œåƒç´ ä¸­é—´æ’å€¼æˆ–è€…å»å€¼ï¼Œä½†æ˜¯labelå°±ä¸èƒ½éšä¾¿æ’ä¸€ä¸ªRGBå€¼ï¼Œ
def voc_rand_crop(feature, label, height, width):
    rect = torchvision.transforms.RandomCrop.get_params(
        feature, (height, width))
    #ï¼Œç¡®å®šå‚æ•°ï¼Œfeatureç¡®å®šè¢«è£å‡çš„å›¾ç‰‡ï¼Œ(h,w)æ˜¯éšæœºè£å‰ªçš„è¾¹ç•Œæ¡†å¤§å°
    feature = torchvision.transforms.functional.crop(feature, *rect)
    #è£å‰ª
    #å‡½æ•°è¿”å›å¼ é‡å’Œå›¾ç‰‡
    label = torchvision.transforms.functional.crop(label, *rect)
    #labelä¹Ÿåšå¯¹åº”è£å‰ª
    return feature, label

imgs = []
for _ in range(n):
    # n=5
    imgs += voc_rand_crop(train_features[0], train_labels[0], 200, 300)
    #è¿”å›çš„æ˜¯å¼ é‡ï¼Œä¹Ÿå°±æ˜¯è¯´åˆ—è¡¨å¯ä»¥é€šè¿‡+å¾—åˆ°å…¶ä»–iterableçš„æ•°æ®
    #iterableçš„å…ƒç´ ä¼šè¢«ä¸€ä¸ªä¸€ä¸ªä¼ å…¥ä½œä¸ºåˆ—è¡¨çš„å…ƒç´ 
    #å› ä¸ºä¸¤ä¸ªä¸‰ç»´å¼ é‡è¢« voc_rand_crop()æ‰“åŒ…æˆäº†ä¸€ä¸ªå…ƒç»„ï¼Œæ‰€ä»¥æ‹†å¼€åˆšå¥½æ˜¯å¼ é‡æœ¬èº«
    #ä½†è¦æ˜¯åŠ initerable,å°±éœ€è¦append
    

imgs = [img.permute(1, 2, 0) for img in imgs]
d2l.show_images(imgs[::2] + imgs[1::2], 2, n);
#æ­¥é•¿ä¸º2å–å€¼ï¼Œç›¸å½“äºé‡æ–°æ’åº
```

**å®šåˆ¶ç±»ï¼ŒæŠŠå¤§éƒ¨åˆ†åŠŸèƒ½éƒ½æ•´åˆè¿›ç±»é‡Œ**

```

class VOCSegDataset(torch.utils.data.Dataset):
    """ä¸€ä¸ªç”¨äºåŠ è½½VOCæ•°æ®é›†çš„è‡ªå®šä¹‰æ•°æ®é›†"""

    def __init__(self, is_train, crop_size, voc_dir):
        self.transform = torchvision.transforms.Normalize(
            mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
        #æŒ‰ç…§RGBæ±‚å‡å€¼å’Œæ–¹å·®
        self.crop_size = crop_size
        features, labels = read_voc_images(voc_dir, is_train=is_train) #è¯»æ–‡ä»¶
        self.features = [self.normalize_image(feature)
                         for feature in self.filter(features)] #ç±»çš„å®ä¾‹è°ƒç”¨ç±»æ–¹æ³•
        self.labels = self.filter(labels)
    
        self.colormap2label = voc_colormap2label()
        #è°ƒç”¨è‰²å·-ç±»åˆ«æ˜ å°„å‘é‡
        print('read ' + str(len(self.features)) + ' examples')

    def normalize_image(self, img):
        return self.transform(img.float() / 255)

    def filter(self, imgs):
        return [img for img in imgs if (
            img.shape[1] >= self.crop_size[0] and
            img.shape[2] >= self.crop_size[1])] #ä¿è¯æ¯”æˆªå–å¤§

    def __getitem__(self, idx):
        feature, label = voc_rand_crop(self.features[idx], self.labels[idx],
                                       *self.crop_size)#(h, w)
        return (feature, voc_label_indices(label, self.colormap2label))
    #æ‹¿å‡ºæ¯ä¸ªå‰ªè£è¿‡çš„featureï¼Œä»¥åŠlabelçš„é¢œè‰²é‡Œå¯¹åº”çš„ç±»åˆ«ç¼–å·
    #labelæ˜¯å·²ç»åšè¿‡è¯­ä¹‰åˆ†ç±»çš„å—ï¼Œæ‰€ä»¥æ¯ä¸ªå—ï¼ˆç±»åˆ«ï¼‰æ ‡å·éƒ½ä¸€è‡´

    def __len__(self):
        return len(self.features)

crop_size = (320, 480)
voc_train = VOCSegDataset(True, crop_size, voc_dir)
voc_test = VOCSegDataset(False, crop_size, voc_dir)
```
**åˆ›å»ºæ•°æ®é›†å’Œæ•´åˆ**

```
batch_size = 64
train_iter = torch.utils.data.DataLoader(voc_train, batch_size, shuffle=True,
                                    drop_last=True,
                                    num_workers=d2l.get_dataloader_workers())
#å› ä¸ºåœ¨å®ä¾‹é‡Œtransformè¿‡ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œæ²¡æœ‰normalize
#å…ˆreadï¼Œå†load
#readç›¸å½“äºæŠŠå›¾ç‰‡ä»æ–‡ä»¶å¤¹çš„pngè½¬æ¢æˆtensorï¼Œå¹¶åštransform
#loaderç›¸å½“äºä»å›¾ç‰‡çš„tensoré›†é‡Œå–æ‰¹é‡
#__getitem__()ä½¿å®ä¾‹å¯ä»¥è¢«ç´¢å¼•ï¼Œæˆ–è€…è¯´æ¯æ¬¡å–æ‰¹é‡è¿”å›çš„å€¼ï¼Œå°±æ˜¯è°ƒç”¨äº†è¯¥å‡½æ•°çš„è¿”å›å€¼
for X, Y in train_iter:
    print(X.shape)
    print(Y.shape)
    break

##æ•´åˆå‡ºæ‰€æœ‰æ•°æ®é›†##
def load_data_voc(batch_size, crop_size):
    voc_dir = d2l.download_extract('voc2012', os.path.join(
        'VOCdevkit', 'VOC2012'))
    num_workers = d2l.get_dataloader_workers()
    train_iter = torch.utils.data.DataLoader(
        VOCSegDataset(True, crop_size, voc_dir), batch_size,
        shuffle=True, drop_last=True, num_workers=num_workers)
    test_iter = torch.utils.data.DataLoader(
        VOCSegDataset(False, crop_size, voc_dir), batch_size,
        drop_last=True, num_workers=num_workers)
    return train_iter, test_iter
```

**å¿ƒå¾—ä½“ä¼š**

å†™äº†è¿™ä¹ˆå¤šä»£ç ï¼Œå‘ç°é¢å‘å¯¹è±¡çš„æ–¹å¼å¯ä»¥å¾ˆæ–¹ä¾¿åœ°å®ç°é›†æˆåŠŸèƒ½ï¼ŒæŠŠæ‰€éœ€è¦çš„å‡½æ•°ã€å±æ€§å®šä¹‰åœ¨ç±»é‡Œï¼Œé€šè¿‡åˆ›é€ å®ä¾‹æ¥ç®€åŒ–ç¨‹åºã€‚å¹¶ä¸”åœ¨å®šä¹‰ç±»æ—¶ï¼Œå¯ä»¥æŠŠä¸ç¨‹åºè¾“å…¥è¾“å‡ºæ— å…³çš„ä¸­é—´å˜é‡éƒ½å†…ç½®åŒ–ï¼Œå®ç°è¾“å…¥â€”â€”è¾“å‡ºçš„ç®€å•é€»è¾‘å…³ç³»ï¼Œæ–¹ä¾¿ç¨‹åºçš„è¿è¡Œã€‚