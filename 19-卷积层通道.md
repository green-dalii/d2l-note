# 19 - 卷积层里的多输入多输出通道

---

### 🎦 本节课程视频地址 👉
[![Bilibil](https://i1.hdslb.com/bfs/archive/66e9026b84cf669fc6c3862ac4648b8d3349275a.jpg@640w_400h_100Q_1c.webp)](https://www.bilibili.com/video/BV1MB4y1F7of)
## 多个输入与输出通道

### 多个输入通道

彩色图像可能有RGB三个通道

转换为灰度会丢失信息

![](\Images/thumb_photoshop-tutorial-r-separate-an-image-into-rgb-color-layers-57693846.png)

每个通道都有一个卷积核，输出是所有通道卷积结果地和。

输入$\bf X$：$c_i\times n_h\times n_w$
核$\bf W$：$c_i\times k_h\times k_w$
输出$\bf Y$：$m_h\times m_w$

$$\bf Y=\sum_{i=0}^{c_i}X_{i,:,:}\star W_{i,:,:}$$

### 多个输出通道

我们可以有多个三位卷积核，每个核生成一个输出通道；

输入$\bf X$：$c_i\times n_h\times n_w$
核$\bf W$：$c_o\times c_i\times k_h\times k_w$
输出$\bf Y$：$c_o\times m_h\times m_w$

$$\bf Y_{i,:,:}=X\star W_{i,:,:,:}$$

### 多个输入和输出通道

每个输出通道可以识别特定模式；
输入通道核识别并组合输入中的模式；

**$1\times 1$卷积层**

$k_h=k_w=1$是一个受欢迎的选择，它不识别空间模式，只是融合通道。

**二维卷积层**

输入$\bf X$：$c_i\times n_h\times n_w$
核$\bf W$：$c_o\times c_i\times k_h\times k_w$
偏差$\bf B$：$c_o\times c_i$
输出$\bf Y$：$c_o\times m_h\times m_w$

$$\bf Y=X\star W+B$$

计算复杂度（浮点计算数FLOP）：$O(c_ic_ok_hk_wm_hm_w)$

$$\begin{array} {l}
c_i=c_o=100\\
k_h=h_w=5\\
m_h=m_w=64\end{array}\quad\rightarrow 1GFLOP$$

10层，1M样本，10PFlops

**总结**

输出通道数时卷积层的超参数
每个输入通道有独立的二维卷积核，所有通道结果相加得到一个输出通道结果
每个输出通道有独立的三维卷积核

### 代码实现
```
import torch
from d2l import torch as d2l
#多输入
def corr2d_multi_in(X, K):
    return sum(d2l.corr2d(x, k) for x, k in zip(X, K))
#多输入多输出
def corr2d_multi_in_out(X, K):
    return torch.stack([corr2d_multi_in(X, k) for k in K], dim=0)
# stack():Concatenates a sequence of tensors along a new dimension.
# All tensors need to be of the same size.
# dim=0

K = torch.stack((K, K + 1, K + 2), dim=0)
K.shape
#1X1验证
def corr2d_multi_in_out_1x1(X, K):
    c_i, h, w = X.shape
    c_o = K.shape[0]
    X = X.reshape((c_i, h * w))
    #拉成一个矩阵
    K = K.reshape((c_o, c_i))
    #拉成一个矩阵
    Y = torch.matmul(K, X)
    #矩阵乘法
    return Y.reshape((c_o, h, w))
    #返回三维

X = torch.normal(0, 1, (3, 3, 3))
K = torch.normal(0, 1, (2, 3, 1, 1))

Y1 = corr2d_multi_in_out_1x1(X, K)
Y2 = corr2d_multi_in_out(X, K)
assert float(torch.abs(Y1 - Y2).sum()) < 1e-6
#调用模块
nn.Conv2d(input_channel, output_channel, kernel_size, padding, stride)
```


