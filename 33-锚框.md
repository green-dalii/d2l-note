# 33 - é”šæ¡†

---

### ğŸ¦ æœ¬èŠ‚è¯¾ç¨‹è§†é¢‘åœ°å€ ğŸ‘‰
[![Bilibil](https://i2.hdslb.com/bfs/archive/fb059336bb681f6908c77a0c3db9d87c2f29680f.jpg@640w_400h_100Q_1c.webp)](https://www.bilibili.com/video/BV1aB4y1K7za)
## é”šæ¡†(Anchor Box)

- ä¸€ç±»ç›®æ ‡æ£€æµ‹ç®—æ³•æ˜¯åŸºäºé”šæ¡†
  - æå‡ºå¤šä¸ªè¢«ç§°ä¸ºé”šæ¡†çš„åŒºåŸŸï¼ˆè¾¹ç¼˜æ¡†ï¼‰
  - é¢„æµ‹æ¯ä¸ªé”šæ¡†é‡Œæ˜¯å¦å«æœ‰å…³æ³¨çš„ç‰©ä½“
  - å¦‚æœæ˜¯ï¼Œé¢„æµ‹ä»è¿™ä¸ªé”šæ¡†åˆ°çœŸå®è¾¹ç¼˜æ¡†çš„åç§»
    - è°ƒæ•´ä½ç½®ï¼Œæ‰¾åˆ°çœŸå®çš„è¾¹ç¼˜æ¡†

![](\Images/1_56UGqknHwtMc9RHRRobL8Q.png)

**IoU-äº¤å¹¶æ¯”**

- ç”¨äºå¯¹æ¯”ä¸¤ä¸ªé”šæ¡†ä¹‹é—´çš„ç›¸ä¼¼åº¦
  - 0è¡¨ç¤ºæ— é‡å ï¼Œ1è¡¨ç¤ºé‡åˆ
- è¿™æ˜¯JacquardæŒ‡æ•°çš„ä¸€ä¸ªç‰¹æ®Šæƒ…å†µ
  - ç»™å®šä¸¤ä¸ªé›†åˆAå’ŒB

$$J(A, B)={|A \bigcap B|\over|A \bigcup B|}$$  

**èµ‹äºˆé”šæ¡†æ ‡å·ï¼ˆè®­ç»ƒï¼‰**
- æ¯ä¸ªé”šæ¡†æ˜¯ä¸€ä¸ªè®­ç»ƒæ ·æœ¬
- å°†æ¯ä¸ªé”šæ¡†ï¼Œè¦ä¹ˆæ ‡æ³¨æˆèƒŒæ™¯ï¼Œè¦ä¹ˆå…³è”ä¸Šä¸€ä¸ªçœŸå®è¾¹ç¼˜æ¡†
  - çœŸå®ç‰©ä½“çš„æ ‡å·+åç§»
- æˆ‘ä»¬å¯èƒ½ä¼šç”Ÿæˆå¤§é‡çš„é”šæ¡†
  - è¿™ä¼šå¯¼è‡´å¤§é‡çš„è´Ÿç±»æ ·æœ¬(èƒŒæ™¯)
- æ¯ä¸ªé”šæ¡†å’Œå„ä¸ªè¾¹ç¼˜æ¡†æ±‚IoUï¼Œå¯¹ä¸€ä¸ªè¾¹ç¼˜æ¡†IoUæœ€å¤§çš„é”šæ¡†ä½œä¸ºå…¶å¯¹åº”æ ‡å·é”šæ¡†ï¼›
- å†åœ¨å…¶ä»–é”šæ¡†é‡Œæ‰¾ä¸ä¸‹ä¸€ä¸ªè¾¹ç¼˜æ¡†æœ€å¤§é‡åˆçš„
- ä»¥æ­¤ç±»æ¨ï¼Œæœ€åå‰©ä¸‹çš„é”šæ¡†ä½œä¸ºè´Ÿç±»

**ä½¿ç”¨éæå¤§å€¼æŠ‘åˆ¶(NMS)è¾“å‡ºï¼ˆé¢„æµ‹ï¼‰**

- æ¯ä¸ªé”šæ¡†é¢„æµ‹ä¸€ä¸ªè¾¹ç¼˜æ¡†
- æŠŠç›¸ä¼¼çš„é¢„æµ‹æ¡†é™¤æ‰
- NMSå¯ä»¥åˆå¹¶ç›¸ä¼¼çš„é¢„æµ‹
  - å¯¹äºéèƒŒæ™¯ç±»çš„é”šæ¡†ï¼Œé€‰ä¸­é’ˆå¯¹æŸä¸€ç±»åˆ«æœ€å¤§é¢„æµ‹å€¼(softmax)çš„é‚£ä¸ª
  - å»æ‰æ‰€æœ‰å…¶ä»–å’Œå®ƒIoUå€¼å¤§äºthreshold $\theta$çš„é¢„æµ‹ï¼ŒæŠŠä½ç½®å½¢çŠ¶æ¥è¿‘çš„æ¡†å»æ‰ã€‚
  - é‡å¤ä¸Šè¿°è¿‡ç¨‹ç›´åˆ°æ‰€æœ‰é¢„æµ‹è¦ä¹ˆè¢«é€‰ä¸­ï¼Œè¦ä¹ˆè¢«å»æ‰

**æ€»ç»“**

- ä¸€ç±»ç›®æ ‡æ£€æµ‹ç®—æ³•åŸºäºé”šæ¡†æ¥é¢„æµ‹ï¼›
- é¦–å…ˆç”Ÿæˆå¤§é‡é”šæ¡†ã€‚å¹¶èµ‹äºˆæ ‡å·ï¼Œæ¯ä¸ªé”šæ¡†ä½œä¸ºä¸€ä¸ªæ ·æœ¬è¿›è¡Œè®­ç»ƒï¼›
- åœ¨é¢„æµ‹æ—¶ï¼Œä½¿ç”¨NMSæ¥å»æ‰å†—ä½™çš„é¢„æµ‹

### ä»£ç å®ç°

ä»¥ä¸€ä¸ªåƒç´ ä¸ºå˜æ¢åŸºå‡†ï¼Œæ”¾å¤§åˆ°å›¾é‡Œï¼Œé”šæ¡†çš„å®½åº¦å’Œé«˜åº¦åˆ†åˆ«æ˜¯$ws\sqrt r$å’Œ$hs/\sqrt r$
- $w$æ˜¯å›¾ç‰‡å®½
- $h$æ˜¯å›¾ç‰‡é«˜
- $s$æ˜¯scaleçš„ç¼©æ”¾æ¯”
- $r$æ˜¯é”šæ¡†çš„å®½é«˜æ¯”

å¯¹äº$(h,w)$çš„å›¾ç‰‡ï¼Œæœ‰$h\times w$ä¸ªåƒç´ ï¼Œåœ¨ä¹˜ä»¥æ‰€æœ‰$s,r$çš„ç»„åˆ$s\times r$ï¼Œå°±æœ‰$h\times w\times s\times r$ä¸ªé”šæ¡†ã€‚

åªè€ƒè™‘ç»„åˆï¼š

$$(s_1,r_1),(s_1,r_2),...,(s_1,r_m),(s_2,r_1),(s_3,r_1),...,(s_n,r_1)$$

ä¹Ÿå°±æ˜¯$s,r$å„è‡ªæœ€åˆç†çš„ä¸€ä¸ªå–å€¼ä¸å…¶ä»–çš„åšåŒ¹é…

å…³äºmatplotlibçš„ä¸€ç‚¹æŠ€å·§ï¼š
![](\Images/å¾®ä¿¡æˆªå›¾_20211229223931.png)

**å¯¼å…¥åŒ…**
```
%matplotlib inline
import torch
from d2l import torch as d2l

torch.set_printoptions(2)
#ç²¾ç®€ä½œå›¾ç²¾åº¦
#Set options for printing. Items shamelessly taken from NumPy
#precision-Number of digits of precision for floating point output (default = 4)

```
**å®šä¹‰åƒç´ çš„é”šæ¡†**
```
def multibox_prior(data, sizes, ratios):
    #dataå°±æ˜¯æŒ‡image_tensor
    in_height, in_width = data.shape[-2:]
    #æå–å›¾ç‰‡é«˜å®½ 660*524
    device, num_sizes, num_ratios = data.device, len(sizes), len(ratios)
    boxes_per_pixel = (num_sizes + num_ratios - 1)
    #s1,r1,s2,r1...
    #boxes_per_pixel=5
    size_tensor = torch.tensor(sizes, device=device)
    #s
    ratio_tensor = torch.tensor(ratios, device=device)
    #r
    
    offset_h, offset_w = 0.5, 0.5
    #ä½¿é”šç‚¹ä¸­å¿ƒä½äºåƒç´ ä¸­å¿ƒçš„åç§»
    steps_h = 1. / in_height
    steps_w = 1. / in_width
    #å®½é«˜ç¼©æ”¾æ­¥é•¿
    center_h = (torch.arange(in_height, device=device) + offset_h) * steps_h
    center_w = (torch.arange(in_width, device=device) + offset_w) * steps_w
    #åƒç´ ä¾æ¬¡æ’åˆ—+0.5å®šä½åˆ°æ¯ä¸ªåƒç´ çš„ä¸­å¿ƒ
    #stepåï¼Œæ”¾ç¼©åˆ°1åƒç´ å†…çš„ä½ç½®
    shift_y, shift_x = torch.meshgrid(center_h, center_w)
    #åˆ›é€ ç½‘æ ¼ (660, 524)
    shift_y, shift_x = shift_y.reshape(-1), shift_x.reshape(-1)
    #reshape(-1)=reshape(1,-1)ï¼Œæ¨ªå‘é“ºæ»¡(1, 660*524=345840)
    
    w = torch.cat((size_tensor * torch.sqrt(ratio_tensor[0]),
                   sizes[0] * torch.sqrt(ratio_tensor[1:]))) \
    * in_height / in_width
    #s*æ ¹å·r*h/w
    #\è¡¨ç¤ºä»£ç æ¢è¡Œ
    h = torch.cat((size_tensor / torch.sqrt(ratio_tensor[0]),
                   sizes[0] / torch.sqrt(ratio_tensor[1:])))
    #s/æ ¹å·r
    
    anchor_manipulations = torch.stack((-w, -h, w, h)).T.repeat(in_height * in_width, 1) / 2
    #stack()é»˜è®¤æŒ‰è¡Œå †ç§¯ï¼Œcat()é»˜è®¤æŒ‰è¡Œè¿æ¥,4*5
    #T:5*4
    #repeat(): Repeats this tensor along the specified dimensions.
    #ä¼ å…¥(m,n)ï¼Œæ²¿è¡Œèµ‹å€¼h*w,æ²¿åˆ—å¤åˆ¶1
    #èµ‹å€¼heightè¡Œå’Œwidthåˆ—
    #å››ä¸ªç‚¹çš„ç›¸å¯¹åæ ‡å¤åˆ¶åˆ°æ¯ä¸ªåƒç´ ä¸Š
    #(5*660*524=1729200, 4)
    
    out_grid = torch.stack([shift_x, shift_y, shift_x, shift_y], dim=1).repeat_interleave(boxes_per_pixel, dim=0)
    #dim=1,æŒ‰åˆ—å¹¶åˆ—ï¼Œå› ä¸ºæ˜¯ä¸€ç»´å¼ é‡(345840,4)
    #repeat_interleave()æŒ‰ç…§å…ƒç´ æŒ‰è¡Œå¤åˆ¶5é(1729200, 4)
    #ä¹Ÿå°±æ˜¯æ¯è¡Œå…ˆå¤åˆ¶äº”éï¼Œå†å¤åˆ¶ä¸‹ä¸€è¡Œ5é
    output = out_grid + anchor_manipulations
    return output.unsqueeze(0)

```
<font color=red> æœ‰ä¸¤ä¸ªé—®é¢˜ï¼š
- å®šä¹‰è¾¹æ¡†å®½é«˜çš„ç®—æ³•ï¼Œä»¥åŠså’Œrçš„å®šä¹‰ï¼›
- å›¾ç‰‡çš„å®½é«˜å¿…é¡»æ˜¯äº’è´¨çš„ï¼Œæ‰èƒ½ä¿è¯x, yåœ¨åˆ†é…çš„æ—¶å€™ä¸é‡å¤ï¼Œè¿™é‡Œçš„æƒ…å†µæ˜¾ç„¶æœ‰é‡å¤ï¼Œå®½é«˜çš„å…¬çº¦æ•°æ˜¯4ï¼Œæ‰€ä»¥é‡å¤äº†4å€ï¼Œæˆ–è€…è¯´é”šæ¡†å°‘äº†4å€ã€‚ 
</font>
**æŒ‰åƒç´ åˆ†å—**
```
img = d2l.plt.imread('../code/Image/Lions.png')
h, w = img.shape[:2]

print(h, w)
X = torch.rand(size=(1, 3, h, w))
Y = multibox_prior(X, sizes=[0.75, 0.5, 0.25], ratios=[1, 2, 0.5])

Y.shape

boxes = Y.reshape(h, w, 5, 4)
#reshapeçš„æ—¶å€™ä»é«˜ç»´åº¦å…ˆå¼€å§‹ï¼Œå…ˆæŒ‰åˆ—æ‹¿ï¼Œå†æ‹¿ä¸‹ä¸€è¡Œï¼›åŒæ ·ï¼Œå…ˆæŒ‰åˆ—å¡«ï¼Œå†å¡«ä¸‹ä¸€è¡Œæ ¼åˆ—
boxes[250, 250, :, :]
```
<font color=red>
è¿™é‡Œçš„åˆ†å—åªæ˜¯æŠŠ $ 5\times4$ çš„é”šæ¡†åˆ†é…åˆ°æ¯ä¸ªåƒç´ çš„ä½ç½®ï¼Œä½†å¹¶ä¸æ˜¯ä¸åƒç´ ç´¢å¼•å‡†ç¡®æ˜ å°„ï¼Œä¾¿äºè§†å¯Ÿ
</font>

**ç»˜åˆ¶é”šæ¡†**
```
def show_bboxes(axes, bboxes, labels=None, colors=None):
    def _make_list(obj, default_values=None):
        if obj is None:
            obj = default_values
        elif not isinstance(obj, (list, tuple)):
            obj = [obj]
        return obj

    #å†…ç½®å‡½æ•°ç”¨_å¼€å¤´å®šä¹‰è¡¨æ˜
    #è™½ç„¶æˆ‘å¯ä»¥è¢«è®¿é—®ï¼Œä½†æ˜¯ï¼Œè¯·æŠŠæˆ‘è§†ä¸ºç§æœ‰å˜é‡ï¼Œä¸è¦éšæ„è®¿é—®
    labels = _make_list(labels)
    colors = _make_list(colors, ['b', 'g', 'r', 'm', 'c'])
    #è¿”å›colors
    for i, bbox in enumerate(bboxes):
        color = colors[i % len(colors)]
        rect = d2l.bbox_to_rect(bbox.detach().numpy(), color)
        #Convert bounding box to matplotlib format
        axes.add_patch(rect)
        if labels and len(labels) > i:
            text_color = 'k' if color == 'w' else 'w'
            axes.text(rect.xy[0], rect.xy[1], labels[i],
                      va='center', ha='center', fontsize=9, color=text_color,
                      bbox=dict(facecolor=color, lw=0))
            #å†™æ–‡æœ¬æ¡†

d2l.set_figsize()
bbox_scale = torch.tensor((w, h, w, h))
#æŠŠæ¡†æ”¾å¤§
fig = d2l.plt.imshow(img)

show_bboxes(fig.axes, boxes[250, 250, :, :] * bbox_scale,#å–å‡ºå¯¹åº”ç‚¹
            ['s=0.75, r=1', 's=0.5, r=1', 's=0.25, r=1', 's=0.75, r=2',
             's=0.75, r=0.5'])

```
![](\Images/å¾®ä¿¡æˆªå›¾_20211229230829.png)

**æ±‚IoU**

![](\Images/ç¤ºæ„å›¾.png)
```
def box_iou(boxes1, boxes2):
    box_area = lambda boxes: ((boxes[:, 2] - boxes[:, 0]) * 
                              (boxes[:, 3] - boxes[:, 1]))
            #(x2-x1)(y2-y1)
    areas1 = box_area(boxes1)#(5, 1)
    areas2 = box_area(boxes2)#(5, 1)
    
    inter_upperlefts = torch.max(boxes1[:, None, :2], boxes2[:, :2])
    inter_lowerrights = torch.min(boxes1[:, None, 2:], boxes2[:, 2:])
    #åˆ‡ç‰‡é‡Œçš„Noneç›¸å½“äºåœ¨è¯¥ä½ç½®å¢åŠ ä¸€ä¸ªç»´åº¦
    #åšè¿ç®—è¦åœ¨åŒä¸€ç»´åº¦ä¸Šï¼Œæœ‰é«˜åˆ°ä½
    #ä¹Ÿå°±æ˜¯è¯´ï¼Œboxes1.slice=(5, 1, 2), boxes.slice=(5, 2),
    #ç”¨(1, 2)å’Œ(5, 2)åšå¹¿æ’­ï¼Œå†ç”¨ç¬¬äºŒç»„ï¼Œç›´åˆ°ç¬¬äº”ç»„
    #æœ€ç»ˆå½¢çŠ¶(5, 5, 2)ï¼Œä»£è¡¨ä¸€ä¸ªç‚¹çš„äº”ä¸ªé”šæ¡†ä¸å¦ä¸€ä¸ªç‚¹çš„äº”ä¸ªé”šæ¡†å·¦ä¸Šã€å³ä¸‹çš„æå°ã€æå¤§å€¼
    
    #äº‹å®ä¸Šï¼Œå›¾ç‰‡åæ ‡yè½´æ˜¯åå‘ï¼Œæ‰€ä»¥å·¦ä¸Šå’Œå³ä¸‹çš„æå°æå¤§æ˜¯å†…æµ‹çš„ç‚¹
    inters = (inter_lowerrights - inter_upperlefts).clamp(min=0)
    #clamp()å®šä¹‰äº†åˆ†æ®µå‡½æ•°ä¸Šä¸‹é™,é˜²æ­¢ä¸¤ä¸ªæ¡†ä¸é‡åˆè€Œå‡ºç°è´Ÿå€¼
    #æ¢è¨€ä¹‹ï¼Œinteræœ¬å°±æ˜¯0
    #shape(5, 5, 2)
    
    inter_areas = inters[:, :, 0] * inters[:, :, 1]
    #ç®—äº¤é›†(5, 5, 1)
    union_areas = areas1[:, None] + areas2 - inter_areas
    #ç®—å¹¶é›†(5, 1, 1)+(5, 1) - (5, 5, 1)=(5, 5, 1)
    return inter_areas / union_areas
```
![](\Images/clamp.png)

**ç»™è¾¹ç•Œæ¡†åˆ†é…é”šæ¡†**
```
def assign_anchor_to_bbox(ground_truth, anchors, device ,iou_threshold=0.5):
    #ground_truthçœŸå®è¾¹ç•Œæ¡†
    num_anchors, num_gt_boxes = anchors.shape[0], ground_truth.shape[0]
    jaccard = box_iou(anchors, ground_truth)
    #(num_anchors, num_gt_boxes, 1)
    anchors_bbox_map = torch.full((num_anchors,), -1, dtype=torch.long, device= device)
    #torch.full():Creates a tensor of size size filled with fill_value. The tensorâ€™s dtype is inferred from fill_value.
    #(num_anchors,)è¡¨ç¤ºåˆ›å»ºé•¿åº¦ä¸ºnum_anchorsçš„ä¸€ç»´tuple,å¡«å……-1
    max_ious, indices = torch.max(jaccard, dim=1)
    #Returns a namedtuple (values, indices)
    #where values is the maximum value of each row of the input tensor in the given dimension dim.
    #And indices is the index location of each maximum value found (argmax).
    #å½“æŠŠmax()ä½œç”¨äºé«˜ç»´åº¦å¼ é‡æ—¶ï¼Œè¿”å›è¯¥ç»´åº¦çš„çŸ©é˜µæ¯ä¸€è¡Œçš„æœ€å¤§å€¼å’Œç´¢å¼•å€¼
    #ä¹Ÿå°±æ˜¯è¯´è¿™é‡Œè¿”å›æ¯ä¸ªé”šæ¡†å¯¹äºæ‰€æœ‰è¾¹ç•Œæ¡†çš„æœ€å¤§iouå’Œå¯¹åº”çš„è¾¹ç•Œæ¡†æ ‡å·
    #max_ious/indices.shape=(num_anchors, 1)
    anc_i = torch.nonzero(max_ious >= 0.5).reshape(-1)
    #å¯¹äºå¤§äº0.5çš„iou,è¿”å›True
    #nonzero()è¿”å›å¼ é‡éé›¶å€¼çš„ç´¢å¼•ï¼Œæ˜¯ä¸€ä¸ªäºŒç»´å¼ é‡ï¼Œå†…éƒ¨ç»´åº¦å­˜å‚¨ç´¢å¼•
    #reshape(-1)=reshape(1,-1),é“ºå¹³ï¼Œå˜æˆä¸€ç»´
    #ä¹Ÿå°±æ˜¯å„ä¸ªç¬¦åˆè¦æ±‚çš„é”šæ¡†çš„æ ‡å·
    box_j = indices[max_ious >= 0.5]
    #ç”¨boolä½œä¸ºç´¢å¼•ï¼Œè¿”å›Trueæ‰€åœ¨ä½ç½®çš„ç´¢å¼•
    #A= [[1], [2], [3]], B = [[True], [False], [True]],
    #A[B]==[A[0],A[2]]==[[1],[3]]
    #æ­¤å¤„å°±æ˜¯è¿”å›å¤§äº0.5çš„é”šæ¡†çš„ç´¢å¼•
    
    ##anc_iå’Œ box[j]æ‰¾åˆ°åˆ°è¾¾thresholdçš„é”šæ¡†ä»¥åŠä¸å…¶æ˜ å°„çš„è¾¹ç•Œæ¡†
    anchors_bbox_map[anc_i] = box_j
    #æŠŠnum_anch*[-1]çš„å‘é‡ï¼Œéè´Ÿé”šæ¡†ä½ç½®æ›¿æ¢ä¸ºå¯¹åº”è¾¹ç•Œæ¡†çš„æ ‡å·ï¼Œå…¶ä½™ä¾æ—§ä¸ºè´Ÿç±»
    col_discard = torch.full((num_anchors,), -1)
    #num_anchors*[-1]
    row_discard = torch.full((num_gt_boxes,), -1)
    #num_gt_boxes*[-1]
    for _ in range(num_gt_boxes):
        max_idx = torch.argmax(jaccard)
        #torch.argmaxå¦‚æœä¸æŒ‡å®šç»´åº¦ï¼Œå°±æ‰€æœ‰å…ƒç´ æ’æˆä¸€è¡Œï¼Œå–æœ€å¤§ä½ç½®
        box_idx = (max_idx % num_gt_boxes).long()
        #long()å°†æ•°å­—æˆ–å­—ç¬¦ä¸²è½¬æ¢ä¸ºä¸€ä¸ªé•¿æ•´å‹ ==ã€‹æ‰¾åˆ°æœ€å¤§å€¼æ‰€åœ¨åˆ—ï¼Œå³è¾¹ç•Œæ¡†åºå·
        anc_idx = (max_idx / num_gt_boxes).long()
        #å¯¹äºä¸€ä¸ªfloat,å»å°æ•°éƒ¨åˆ†å–æ•´ ==ã€‹æ‰¾åˆ°æœ€å¤§å€¼æ‰€åœ¨è¡Œï¼Œå³é”šæ¡†åºå·
        anchors_bbox_map[anc_idx] = box_idx #æŠŠé”šæ¡†ä½ç½®çš„ï¼ˆ-1ï¼‰æ¢åšè¾¹ç•Œæ¡†çš„å·
        jaccard[:, box_idx] = col_discard #æŠŠæ‰€åœ¨åˆ—é‡æ–°èµ‹å€¼ä¸ºè´Ÿç±»
        jaccard[anc_idx, :] = row_discard #æŠŠæ‰€åœ¨è¡Œé‡æ–°èµ‹å€¼ä¸ºè´Ÿç±»
    return anchors_bbox_map
    # éå†ç»“æŸ anchors_bbox_map.shape=(num_anchors, 1)ï¼ŒæŸä¸ªgtæ‰€åœ¨è¡Œæ ‡å·ä¸å¯¹åº”gtæ˜ å°„ï¼Œå…¶ä½™ä¸º-1ã€‚
```
<font color=red>
åœ¨ for loop ä¹‹å‰çš„ä»£ç å¹¶æ²¡æœ‰å®é™…ç”¨åˆ°ï¼Œç›¸å½“äºä¸€ç§è¡¥å……ç®—æ³•ï¼Œä¿è¯ç›¸å…³åº¦æœ‰ä¸€ä¸ªé˜ˆå€¼ï¼Œè€Œä¸”äº§ç”Ÿäº†ä¸€ä¸ªbugâ€”â€”å¾ªç¯ä¹‹å‰å¯¹æ‰€æœ‰é”šæ¡†åšäº†é˜ˆå€¼æ˜ å°„ï¼Œä½†åœ¨å¾ªç¯ä¸­é‡æ–°æ˜ å°„çš„æ—¶å€™å‰é¢å·²ç»èµ‹å€¼çš„anchors_bbox_mapæ²¡æœ‰è¢«å®Œå…¨è¦†ç›–ï¼Œæ‰€ä»¥å¯¹äºåŒä¸€ä¸ªè¾¹ç•Œæ¡†ï¼Œæœ‰ä¸æ­¢ä¸€ä¸ªé”šæ¡†çš„æ˜ å°„ã€‚
</font>

å…³äºå¤šç»´åº¦å¼ é‡è®¡ç®—:


![](\Images/é«˜ç»´åº¦å¼ é‡è¿ç®—.png)

**é”šæ¡†ä¸è¾¹ç•Œæ¡†åç§»æ‹Ÿåˆ**

åšNormalizeï¼Œå¹¶ä¸”æ–¹å·®è¾ƒå¤§ï¼Œåˆ†æ•£æ ·æœ¬ï¼Œä¾¿äºè®¡ç®—

 å‡è®¾ä¸€ä¸ªé”šæ¡† A è¢«åˆ†é…äº†ä¸€ä¸ªçœŸå®è¾¹ç•Œæ¡† B ã€‚ ä¸€æ–¹é¢ï¼Œé”šæ¡† A çš„ç±»åˆ«å°†è¢«æ ‡è®°ä¸ºä¸ B ç›¸åŒã€‚ å¦ä¸€æ–¹é¢ï¼Œé”šæ¡† A çš„åç§»é‡å°†æ ¹æ® B å’Œ A ä¸­å¿ƒåæ ‡çš„ç›¸å¯¹ä½ç½®ä»¥åŠè¿™ä¸¤ä¸ªæ¡†çš„ç›¸å¯¹å¤§å°è¿›è¡Œæ ‡è®°ã€‚ é‰´äºæ•°æ®é›†å†…ä¸åŒçš„æ¡†çš„ä½ç½®å’Œå¤§å°ä¸åŒï¼Œæˆ‘ä»¬å¯ä»¥å¯¹é‚£äº›ç›¸å¯¹ä½ç½®å’Œå¤§å°åº”ç”¨å˜æ¢ï¼Œä½¿å…¶è·å¾—åˆ†å¸ƒæ›´å‡åŒ€ä¸”æ˜“äºæ‹Ÿåˆçš„åç§»é‡ã€‚ç»™å®šæ¡† A å’Œ B ï¼Œä¸­å¿ƒåæ ‡åˆ†åˆ«ä¸º $(x_a,y_a)$ å’Œ $(x_b,y_b)$ ï¼Œå®½åº¦åˆ†åˆ«ä¸º $w_a$ å’Œ $w_b$ ï¼Œé«˜åº¦åˆ†åˆ«ä¸º $h_a$ å’Œ $h_b$ ã€‚ æˆ‘ä»¬å¯ä»¥å°† A çš„åç§»é‡æ ‡è®°ä¸º:

 $$\left({{x_b-x_a\over w_a}-\mu_x\over \sigma_x},{{y_b-y_a\over h_a}-\mu_y\over \sigma_y},{\log{w_b\over w_a}-\mu_w\over\sigma_w},{\log{h_b\over h_a}-\mu_h\over\sigma_h}\right)$$

 é€šå¸¸
 $\mu_x=\mu_y=\mu_w=\mu_h=0$
 $\sigma_x=\sigma_y=0.1,\ \sigma_w=\sigma_h=0.2$

 ```
 #anchors.shape=(num_anchors=num_gt, 4)
def offset_boxes(anchors, assigned_bb, eps=1e-6):
    c_anc = d2l.box_corner_to_center(anchors)
    #ä¸­å¿ƒæ³•è¡¨ç¤ºé”šæ¡†å››ç»´
    c_assigned_bb = d2l.box_corner_to_center(assigned_bb)
    #ä¸­å¿ƒæ³•è¡¨ç¤ºæ˜ å°„è¾¹ç•Œæ¡†å››ç»´
    offset_xy = 10 * (c_assigned_bb[:, :2] - c_anc[:, :2]) / c_anc[:, 2:]
    ##åç§»è®¡ç®— /sigma=0.1=> *10
    offset_wh = 5 * torch.log(eps + c_assigned_bb[:, 2:] / c_anc[:, 2:])
    ## /sigma=0.2 => *5
    offset = torch.cat([offset_xy, offset_wh], axis=1)
    ##cat()æŒ‰ç»´åº¦è¿æ¥ï¼Œä¹Ÿå°±æ˜¯åœ¨è¯¥ç»´åº¦ä¸Šåšå‡ºæ”¹å˜ã€‚
    ##axiså’Œdimå¯ä»¥äº’æ¢
    ##off_set.shape=(num_gt, 4)
    return offset

def multibox_target(anchors, labels):
    #labels=è¾¹ç•Œæ¡†æ ‡å·
    batch_size, anchors = labels.shape[0], anchors.squeeze(0)
    #labels.shape[0]å°±æ˜¯ä¸€æ¬¡ä¼ å…¥çš„æ–‡ä»¶æ‰¹é‡ï¼Œå¦‚æœæ²¡æœ‰å¤šä½™ï¼ˆä¸º1ï¼‰ç»´åº¦ï¼Œå°±è¿”å›æœ¬èº«
    #squeeze(0)é™ä½ç»´åº¦
    batch_offset, batch_mask, batch_class_labels = [], [], []
    device, num_anchors = anchors.device, anchors.shape[0]
    
    for i in range(batch_size):
        label = labels[i, :, :]
        #è¿”å›æ ‡å·ï¼ˆç‰©ä½“æ•°é‡ï¼‰ï¼Œæˆ–è€…è¯´è¾¹ç•Œæ¡†çš„æ•°é‡å’Œå››ç»´
        anchors_bbox_map = assign_anchor_to_bbox(
            label[:, 1:], anchors, device)
        #ç¬¬ä¸€ä¸ªç‰¹å¾æ˜¯ç‰©ä½“ç±»åˆ«ï¼Œå¹¶ä¸éœ€è¦ï¼Œæ‰€ä»¥åªå–å‡ºå››ç»´
        #æ±‚å‡ºä¸é”šæ¡†çš„æ˜ å°„
        bbox_mask = ((anchors_bbox_map >= 0).float().unsqueeze(-1)).repeat(
            1, 4)
        #æ±‚å‡ºæ­£ç±»ï¼Œå†æŠŠboolè½¬åŒ–ä¸ºæµ®ç‚¹æ•°(0., 1.),shape=(num_anchors, 1)
        #å†æ²¿åˆ—å¤åˆ¶ï¼Œshape(num_anchors, 4)
        class_labels = torch.zeros(num_anchors, dtype=torch.long,
                                   device=device)
        #num_anchors*(0)å‘é‡
        assigned_bb = torch.zeros((num_anchors, 4), dtype=torch.float32,
                                  device=device)
        #(num_anchors,4) * 0äºŒç»´å¼ é‡
        indices_true = torch.nonzero(anchors_bbox_map >= 0)
        #è¿”å›æ­£ç±»åœ¨anchorså‘é‡é‡Œçš„ç´¢å¼•
        bb_idx = anchors_bbox_map[indices_true]
        #æŠŠæ­£ç±»ç´¢å¼•çš„å€¼æå–å‡ºæ¥ï¼Œä¹Ÿå°±æ˜¯æ‰€æ˜ å°„çœŸå®è¾¹ç•Œæ¡†çš„æ ‡å·
        class_labels[indices_true] = label[bb_idx, 0].long() + 1
        #å‰é¢å®šä¹‰çš„å…¨0å‘é‡,æŠŠè¢«æ˜ å°„è¾¹ç•Œæ¡†å¯¹åº”ç‰©ä½“ç±»å‹(åˆ‡ç‰‡[0]) + 1èµ‹å€¼ç»™å®ƒï¼Œåœ¨æ‰“å°çš„æ—¶å€™ä¸è‡³äºå‡ºç°ç¬¬0ç±»ã€‚
        assigned_bb[indices_true] = label[bb_idx, 1:]
        #æŠŠæ˜ å°„gtçš„4ç»´æ˜ å°„ç»™é”šæ¡†
        
        offset = offset_boxes(anchors, assigned_bb) * bbox_mask
        #æ±‚å‡ºåç§»ï¼ŒæŠŠè´Ÿç±»çš„åç§»å€¼å…¨éƒ¨æ¸…é›¶
        batch_offset.append(offset.reshape(-1))
        #reshape(-1)=reshape(1,-1),é“ºå¹³ï¼Œå˜æˆä¸€ç»´, 4*num_anchorså‘é‡
        #åœ¨åˆ—è¡¨é‡ŒåŠ å¼ é‡
        batch_mask.append(bbox_mask.reshape(-1))
        #reshape(-1)=reshape(1,-1),é“ºå¹³ï¼Œå˜æˆä¸€ç»´, 4*num_anchorså‘é‡ï¼Œæœ‰æ˜ å°„ä¸º4*1ï¼Œæ— æ˜ å°„ä¸º4*0
        batch_class_labels.append(class_labels)
        #num_anchorsé•¿åº¦å‘é‡ï¼Œæœ‰æ˜ å°„ç´¢å¼•ä¸ºç‰©ä½“ç±»å‹+1ï¼Œå…¶ä½™ä¸º0
    bbox_offset = torch.stack(batch_offset)
    # æŠŠåŸåˆ—è¡¨batch_offsetå˜æˆ(batch_size, 4*num_anchors)çš„äºŒç»´å¼ é‡bbox_offset
    bbox_mask = torch.stack(batch_mask)
    # æŠŠåŸåˆ—è¡¨batch_maskå˜æˆ(batch_size, 4*num_anchors)çš„äºŒç»´å¼ é‡bbox_maskï¼Œæœ‰æ˜ å°„ä¸º4*1ï¼Œæ— æ˜ å°„ä¸º4*0
    class_labels = torch.stack(batch_class_labels)
    #æŠŠåŸåˆ—è¡¨batch_class_labelså˜æˆ(batch_size, num_anchors)çš„äºŒç»´å¼ é‡class_labelsï¼Œæœ‰æ˜ å°„ç´¢å¼•ä¸ºç‰©ä½“ç±»å‹+1ï¼Œå…¶ä½™ä¸º0
    return (bbox_offset, bbox_mask, class_labels)
    # stack()å¯ä»¥æŠŠåˆ—è¡¨/å…ƒç»„é‡Œçš„å¼ é‡å…ƒç´ æ²¿ä¸€ä¸ªç»´åº¦åˆå¹¶æˆä¸€ä¸ªå¼ é‡
 ```
**æ —å­**

```
ground_truth = torch.tensor([[0, 0.1, 0.08, 0.52, 0.92],
                         [1, 0.55, 0.2, 0.9, 0.88]])
anchors = torch.tensor([[0, 0.1, 0.2, 0.3], [0.15, 0.2, 0.4, 0.4],
                    [0.63, 0.05, 0.88, 0.98], [0.66, 0.45, 0.8, 0.8],
                    [0.57, 0.3, 0.92, 0.9]])

fig = d2l.plt.imshow(img)
show_bboxes(fig.axes, ground_truth[:, 1:] * bbox_scale, ['dog', 'cat'], 'k')
show_bboxes(fig.axes, anchors * bbox_scale, ['0', '1', '2', '3', '4']);
labels = multibox_target(anchors.unsqueeze(dim=0),
                         ground_truth.unsqueeze(dim=0))
#unsqueeze(dim=0)è¡¨ç¤ºæ·»åŠ ä¸€ä¸ªç»´åº¦æ‰¹é‡å¤§å°ï¼Œå› ä¸ºåªä¼ äº†ä¸€å¼ å›¾ï¼Œæ‰€ä»¥æ˜¯1
#å¯¹åº”å‡½æ•°é‡Œçš„anchors.squeeze(0)
#è¿”å›é•¿åº¦ä¸ºbbox_offset=20ï¼Œ
labels[2], labels[0]
```
![](/Images/æ —å­.png)


**ç”¨æœ€å¤§æŠ‘åˆ¶åŒ–ç®€**
```
#æ ¹æ®é¢„æµ‹å€¼é€†æ±‚è¾¹ç•Œæ¡†ä½ç½®
def offset_inverse(anchors, offset_preds):
    
    anc = d2l.box_corner_to_center(anchors)
    #å˜æˆä¸­å¿ƒ4ç»´
    pred_bbox_xy = (offset_preds[:, :2] * anc[:, 2:] / 10) + anc[:, :2]
    pred_bbox_wh = torch.exp(offset_preds[:, 2:] / 5) * anc[:, 2:]
    pred_bbox = torch.cat((pred_bbox_xy, pred_bbox_wh), axis=1)
    predicted_bbox = d2l.box_center_to_corner(pred_bbox)
    #è¿”å›é¢„æµ‹çš„è¾¹ç•Œæ¡†ä½ç½®
    #shape=(num_boxes, 4)
    return predicted_bbox
```

```
#æœ€å¤§æŠ‘åˆ¶ç­›é€‰å‡½æ•°
def nms(boxes, scores, iou_threshold):
    #socresæ˜¯é¢„æµ‹è¯¥é”šæ¡†å±äºæŸä¸ªè¾¹ç•Œæ¡†çš„ç½®ä¿¡åº¦
    
    B = torch.argsort(scores, dim=-1, descending=True)
    #argsort()å¯¹äºå¼ é‡å…ƒç´ æ’åºï¼Œè¿”å›ç´¢å¼•æ’åºï¼Œé»˜è®¤ä»ä½åˆ°é«˜ï¼Œ descending_default=True
    keep = []  
    while B.numel() > 0:
        i = B[0]
        keep.append(i)
        if B.numel() == 1: break
        iou = box_iou(boxes[i, :].reshape(-1, 4), #å˜æˆè¡Œå‘é‡
                      boxes[B[1:], :].reshape(-1, 4)).reshape(-1)#å˜æˆè¡Œå‘é‡len=(num_boxes-1)
        inds = torch.nonzero(iou <= iou_threshold).reshape(-1)#æŠŠé‡å åº¦å°äºé˜ˆå€¼çš„ç´¢å¼•æ‹¿å‡ºæ¥
        B = B[inds + 1]#å› ä¸ºæ‹¿å‡ºå»çš„ç´¢å¼•ä¸åŒ…å«B[0]
    return torch.tensor(keep, device=boxes.device) #è¿”å›ä¸å…¶ä»–éƒ½ä¸é‡åˆçš„boxesçš„ç´¢å¼•
```
```
#æœ€å¤§æŠ‘åˆ¶åº”ç”¨å‡½æ•°

def multibox_detection(cls_probs, offset_preds, anchors, nms_threshold=0.5,
                       pos_threshold=0.009999999):
    #cls_probsä¼ å…¥(batch_size, labels, scores)
    #offset_predsåç§»é¢„æµ‹ç»“æœ
    device, batch_size = cls_probs.device, cls_probs.shape[0]
    anchors = anchors.squeeze(0) #åŠ å…¥é€šé“é¡¹
    num_classes, num_anchors = cls_probs.shape[1], cls_probs.shape[2]
    #num_classesç±»åˆ«æ•°=è¾¹ç•Œæ¡†æ•°ï¼Œnum_anchorsæ¯ä¸ªç‰©ä½“çš„è¾¹ç•Œæ¡†æ•°
    out = []
    for i in range(batch_size):
        cls_prob, offset_pred = cls_probs[i], offset_preds[i].reshape(-1, 4)
        #æ¯å¼ å›¾çš„é¢„æµ‹(labels, boxes, 4d)
        
        conf, class_id = torch.max(cls_prob[1:], 0) #dim=0
        #æ¯ä¸ªé”šæ¡†å¯¹äºæ¯ä¸ªç±»åˆ«çš„æœ€å¤§é¢„æµ‹ï¼Œä»¥åŠå¯¹åº”ç±»åˆ«çš„index
        
        predicted_bb = offset_inverse(anchors, offset_pred)
        #è¿”å›è¾¹ç•Œæ¡†å››ç»´
        keep = nms(predicted_bb, conf, nms_threshold)
        #å¾—åˆ°è¿˜æœ‰ç”¨çš„é”šæ¡†

       
        all_idx = torch.arange(num_anchors, dtype=torch.long, device=device)
        combined = torch.cat((keep, all_idx))
        #è¿æ¥æœ‰ç”¨å’Œæ‰€æœ‰
        uniques, counts = combined.unique(return_counts=True)
        #è¿”å›batchsizeé•¿åº¦å‘é‡ï¼Œä»¥åŠæ¯ä¸ªboxå‡ºç°çš„æ¬¡æ•°
        non_keep = uniques[counts == 1]
        #æŠŠåªå‡ºç°ä¸€æ¬¡çš„é”šæ¡†ç¼–å·æ‹¿å‡ºæ¥
        all_id_sorted = torch.cat((keep, non_keep))
        #æŠŠæœ‰ç”¨çš„å’Œæ²¡ç”¨çš„è¿æ¥
        class_id[non_keep] = -1
        #æŠŠæ²¡ç”¨çš„æ ‡è®°æˆè´Ÿç±»
        #æŠŠç´¢å¼•çš„æ ‡å·åšæˆtensorï¼Œå¯ä»¥æŒ‰é¡ºåºæå–å¯¹åº”å…ƒç´ ç»„æˆæ–°çš„tensor
        class_id = class_id[all_id_sorted]
        #å†æŒ‰ç…§æœ‰ç”¨çš„é¡ºåºæ’åˆ—ï¼ŒæŠŠè´Ÿç±»æ”¾åœ¨æœ€å
        conf, predicted_bb = conf[all_id_sorted], predicted_bb[all_id_sorted]
        #æŠŠè¿™ä¸¤ä¸ªä¹ŸæŒ‰é¡ºåºæ’
        below_min_idx = (conf < pos_threshold)
        #pos_thresholdæ˜¯èƒŒæ™¯ç±»çš„é˜ˆå€¼
        class_id[below_min_idx] = -1
        #boolä½œä¸ºç´¢å¼•ï¼Œå°±æ˜¯ç´¢å¼•Trueçš„ä½ç½®ï¼ŒFalseå°±å¿½ç•¥
        #æŠŠèƒŒæ™¯ç±»ä¹Ÿæ ‡è®°æˆ-1
        conf[below_min_idx] = 1 - conf[below_min_idx]
        pred_info = torch.cat((class_id.unsqueeze(1),
                               conf.unsqueeze(1),
                               predicted_bb), dim=1)
        #æŒ‰åˆ—è¿æ¥ï¼Œ[ç±»åˆ«ï¼Œç½®ä¿¡ç‡ï¼Œè¾¹ç•Œæ¡†å››ç»´]
        out.append(pred_info)
    return torch.stack(out)
```
**å†ä¸€ä¸ªæ —å­**
<font color=red>æˆ‘ä¸å¤ªç†è§£cls_probsç¬¬ä¸€è¡Œå…¨é›¶ä»£è¡¨ä»€ä¹ˆ</font>
```
anchors = torch.tensor([[0.1, 0.08, 0.52, 0.92], [0.08, 0.2, 0.56, 0.95],
                      [0.15, 0.3, 0.62, 0.91], [0.55, 0.2, 0.9, 0.88]])
offset_preds = torch.tensor([0] * anchors.numel())
cls_probs = torch.tensor([[0] * 4,  
                      [0.9, 0.8, 0.7, 0.1],  
                      [0.1, 0.2, 0.3, 0.9]])  

fig = d2l.plt.imshow(img)
show_bboxes(fig.axes, anchors * bbox_scale,
            ['dog=0.9', 'dog=0.8', 'dog=0.7', 'cat=0.9'])

output = multibox_detection(cls_probs.unsqueeze(dim=0),
                            offset_preds.unsqueeze(dim=0),
                            anchors.unsqueeze(dim=0),
                            nms_threshold=0.5)
output

fig = d2l.plt.imshow(img)
for i in output[0].detach().numpy():
    if i[0] == -1:
        continue
    #å¿½ç•¥è´Ÿç±»
    label = ('dog=', 'cat=')[int(i[0])] + str(i[1])
    #ç±»åˆ«+ç½®ä¿¡ç‡
    show_bboxes(fig.axes, [torch.tensor(i[2:]) * bbox_scale], label)
```
![](\Images/è¾¹ç•Œæ¡†é¢„æµ‹.png)