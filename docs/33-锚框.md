# 33 - é”šæ¡†

---

### ğŸ¦ æœ¬èŠ‚è¯¾ç¨‹è§†é¢‘åœ°å€ ğŸ‘‡

[![Bilibil](https://i2.hdslb.com/bfs/archive/fb059336bb681f6908c77a0c3db9d87c2f29680f.jpg@640w_400h_100Q_1c.webp)](https://www.bilibili.com/video/BV1aB4y1K7za)

## é”šæ¡†(Anchor Box)

ç›®æ ‡æ£€æµ‹ç®—æ³•é€šå¸¸ä¼šåœ¨è¾“å…¥å›¾åƒä¸­é‡‡æ ·å¤§é‡çš„åŒºåŸŸï¼Œç„¶ååˆ¤æ–­è¿™äº›åŒºåŸŸä¸­æ˜¯å¦åŒ…å«æˆ‘ä»¬æ„Ÿå…´è¶£çš„ç›®æ ‡ï¼Œå¹¶è°ƒæ•´åŒºåŸŸè¾¹ç•Œä»è€Œæ›´å‡†ç¡®åœ°é¢„æµ‹ç›®æ ‡çš„çœŸå®è¾¹ç•Œæ¡†ï¼ˆground-truth bounding boxï¼‰ã€‚

ä¸€ç±»ç›®æ ‡æ£€æµ‹ç®—æ³•æ˜¯åŸºäºé”šæ¡†

- æå‡ºå¤šä¸ªè¢«ç§°ä¸ºé”šæ¡†çš„åŒºåŸŸï¼ˆè¾¹ç¼˜æ¡†ï¼‰
- é¢„æµ‹æ¯ä¸ªé”šæ¡†é‡Œæ˜¯å¦å«æœ‰å…³æ³¨çš„ç‰©ä½“
- å¦‚æœæ˜¯ï¼Œé¢„æµ‹ä»è¿™ä¸ªé”šæ¡†åˆ°çœŸå®è¾¹ç¼˜æ¡†çš„åç§»
- è°ƒæ•´ä½ç½®ï¼Œæ‰¾åˆ°çœŸå®çš„è¾¹ç¼˜æ¡†

![output_anchor](https://zh.d2l.ai/_images/output_anchor_f592d1_51_0.svg)

> å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œè“è‰²çš„é”šæ¡†æ•ˆæœæ˜¯è¾ƒå¥½çš„ï¼Œå…¶æ•ˆæœè¡¡é‡é€šå¸¸ä½¿ç”¨IoUï¼ˆäº¤å¹¶æ¯”ï¼‰æŒ‡æ ‡

### IoU - äº¤å¹¶æ¯”

![iou](https://zh.d2l.ai/_images/iou.svg)

- IoU ç”¨äºå¯¹æ¯”ä¸¤ä¸ªé”šæ¡†ä¹‹é—´çš„**ç›¸ä¼¼åº¦**
  - 0 è¡¨ç¤ºæ— é‡å ï¼Œ1 è¡¨ç¤ºé‡åˆ
- è¿™æ˜¯ Jacquard æŒ‡æ•°çš„ä¸€ä¸ªç‰¹æ®Šæƒ…å†µ
  - ç»™å®šä¸¤ä¸ªé›†åˆ A å’Œ B

$$J(A, B)={|A \bigcap B|\over|A \bigcup B|}$$

![IoU](Images/1_56UGqknHwtMc9RHRRobL8Q.png)

### èµ‹äºˆé”šæ¡†æ ‡å·ï¼ˆè®­ç»ƒï¼‰

- å°†æ¯ä¸ªé”šæ¡†è§†ä¸ºä¸€ä¸ªè®­ç»ƒæ ·æœ¬
- å°†æ¯ä¸ªé”šæ¡†ï¼Œè¦ä¹ˆæ ‡æ³¨æˆèƒŒæ™¯ï¼Œè¦ä¹ˆå…³è”ä¸Šä¸€ä¸ªçœŸå®è¾¹ç¼˜æ¡†
  
  > é”šæ¡†ç»„æˆï¼šçœŸå®ç‰©ä½“çš„æ ‡å·ï¼ˆclassï¼‰ + è·ç¦»çœŸå®ç‰©ä½“è¾¹ç•Œæ¡†çš„åç§»ï¼ˆoffsetï¼‰

- æˆ‘ä»¬å¯èƒ½ä¼šç”Ÿæˆå¤§é‡çš„é”šæ¡†ï¼ˆé”šæ¡†å¤šäºè¾¹ç•Œæ¡†ï¼‰

  > è¿™ä¼šå¯¼è‡´å¤§é‡çš„è´Ÿç±»æ ·æœ¬ï¼ˆèƒŒæ™¯ï¼‰

ä¸€èˆ¬ä½¿ç”¨çŸ©é˜µè¡¨ç¤ºï¼Œå…¶ä¸­åˆ—è¡¨ç¤º**çœŸå®çš„è¾¹ç•Œæ¡†ç´¢å¼•**ï¼ˆå¦‚ä¸‹å›¾æ‰€ç¤ºï¼ŒçœŸå®è¾¹ç•Œæ¡†ä¸º4ä¸ªï¼Œä¸€èˆ¬ä¸ºæ ‡æ³¨å¥½çš„æ•°æ®ï¼‰ï¼Œè¡Œä»£è¡¨ç”Ÿæˆçš„**é”šæ¡†ç´¢å¼•**ï¼ˆä¸‹å›¾æ‰€ç¤ºé”šæ¡†ä¸º9ä¸ªï¼Œä¸€èˆ¬ä¸ºå›ºå®šç”Ÿæˆæˆ–æ ¹æ®å›¾ç‰‡ç”Ÿæˆï¼‰ï¼Œå…ƒç´ å¡«å……é”šæ¡†ä¸è¾¹ç•Œæ¡†çš„**IoUå€¼**ã€‚ä¸‹å›¾å±•ç¤ºäº†å¦‚ä½•èµ‹äºˆé”šæ¡†æ ‡å·çš„ä¸€ç§ç®—æ³•ï¼š

![anchor-label](https://zh.d2l.ai/_images/anchor-label.svg)

- å¯¹ä¸Šè¿°çŸ©é˜µå–å‡º**æœ€å¤§å€¼**ï¼ˆå¦‚å·¦ä¾§å›¾æ‰€ç¤ºï¼Œæœ€å¤§å€¼ä¸º$x_{23}$ï¼‰ï¼Œæ‰€åœ¨è¡Œå¯¹åº”çš„é”šæ¡†åˆ™ä¸è¯¥è¾¹ç•Œæ¡†å…³è”ï¼ˆ`é”šæ¡†2`ä¸`è¾¹ç•Œæ¡†3`å…³è”ï¼‰ï¼Œå¹¶å°†è¯¥è¡Œä¸è¯¥åˆ—å…ƒç´ â€œæŠ é™¤â€
- åœ¨ä¸Šæ­¥â€œæŠ é™¤â€åçš„çŸ©é˜µå†…é‡å¤ä»¥ä¸Šæ“ä½œï¼ˆå¦‚ä¸­å›¾ï¼Œæ‰¾åˆ°æœ€å¤§å€¼$x_{71}$ï¼Œå…³è”`é”šæ¡†7`ä¸`è¾¹ç•Œæ¡†1`ï¼Œç»§ç»­æŠ é™¤`è¡Œ7åˆ—1`ï¼‰
- ç»§ç»­é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´åˆ°æ‰€æœ‰è¾¹ç•Œæ¡†å…³è”å®Œæ¯•ï¼Œæœ€åéå†å‰©ä¸‹çš„é”šæ¡†ï¼Œç„¶åæ ¹æ®é˜ˆå€¼ç¡®å®šæ˜¯å¦ä¸ºå®ƒä»¬åˆ†é…çœŸå®è¾¹ç•Œæ¡†

### ä½¿ç”¨éæå¤§å€¼æŠ‘åˆ¶(NMS)è¾“å‡ºï¼ˆé¢„æµ‹ï¼‰

- æ¯ä¸ªé”šæ¡†è¦é¢„æµ‹ä¸€ä¸ªè¾¹ç¼˜æ¡†
- NMS å¯ä»¥åˆå¹¶ç›¸ä¼¼çš„é¢„æµ‹
  - å¯¹äºéèƒŒæ™¯ç±»çš„é”šæ¡†ï¼Œé€‰ä¸­é’ˆå¯¹æŸä¸€ç±»åˆ«æœ€å¤§é¢„æµ‹å€¼(softmax)çš„é”šæ¡†ï¼ˆå¦‚è“è‰²çš„`dog=0.9`æ¡†ï¼‰
  - å»æ‰æ‰€æœ‰å…¶ä»–å’Œå®ƒ IoU å€¼å¤§äºé˜ˆå€¼ $\theta$ çš„é¢„æµ‹é”šæ¡†ï¼ˆå¦‚ç»¿è‰²ã€çº¢è‰²æ¡†ï¼‰
  - é‡å¤ä¸Šè¿°è¿‡ç¨‹ç›´åˆ°æ‰€æœ‰é¢„æµ‹è¦ä¹ˆè¢«é€‰ä¸­ï¼Œè¦ä¹ˆè¢«å»æ‰

![](https://zh.d2l.ai/_images/output_anchor_f592d1_177_0.svg)

![](https://zh.d2l.ai/_images/output_anchor_f592d1_195_0.svg)

### æ€»ç»“

- ä¸€ç±»ç›®æ ‡æ£€æµ‹ç®—æ³•åŸºäºé”šæ¡†æ¥é¢„æµ‹ï¼›
- é¦–å…ˆç”Ÿæˆå¤§é‡é”šæ¡†ã€‚å¹¶èµ‹äºˆæ ‡å·ï¼Œæ¯ä¸ªé”šæ¡†ä½œä¸ºä¸€ä¸ªæ ·æœ¬è¿›è¡Œè®­ç»ƒï¼›
- åœ¨é¢„æµ‹æ—¶ï¼Œä½¿ç”¨ NMS æ¥å»æ‰å†—ä½™çš„é¢„æµ‹

## ä»£ç å®ç°

- å¯¼å…¥åŒ…

```python
%matplotlib inline
import torch
from d2l import torch as d2l

torch.set_printoptions(2)
# ç²¾ç®€ä½œå›¾ç²¾åº¦
# Set options for printing. Items shamelessly taken from NumPy
# precision-Number of digits of precision for floating point output (default = 4)
```

> å…³äº matplotlib å›¾è¡¨ç»„æˆï¼š
![amtplotlib](Images/å¾®ä¿¡æˆªå›¾_20211229223931.png)

- å®šä¹‰åƒç´ çš„é”šæ¡†

å‡è®¾è¾“å…¥å›¾åƒçš„**é«˜åº¦**ä¸º $h$ï¼Œ**å®½åº¦**ä¸º $w$ã€‚ æˆ‘ä»¬ä»¥å›¾åƒçš„æ¯ä¸ªåƒç´ ä¸ºä¸­å¿ƒç”Ÿæˆä¸åŒå½¢çŠ¶çš„é”šæ¡†ï¼šé”šæ¡†å å›¾åƒçš„**ç¼©æ”¾æ¯”**ä¸º $s\in (0,1]$ ï¼Œé”šæ¡†**å®½é«˜æ¯”**ä¸º $r>0$ã€‚åˆ™é”šæ¡†çš„å®½åº¦å’Œé«˜åº¦åˆ†åˆ«æ˜¯$ws\sqrt r$å’Œ$hs/\sqrt r$ã€‚

å¯¹äº$(h,w)$çš„å›¾ç‰‡ï¼Œæœ‰$h\times w$ä¸ªåƒç´ ï¼Œåœ¨ä¹˜ä»¥æ‰€æœ‰$s,r$çš„ç»„åˆ$s\times r$ï¼Œå°±æœ‰$h\times w\times s\times r$ä¸ªé”šæ¡†ã€‚

åªè€ƒè™‘ç»„åˆï¼š

$$(s_1,r_1),(s_1,r_2),...,(s_1,r_m),(s_2,r_1),(s_3,r_1),...,(s_n,r_1)$$

ä¹Ÿå°±æ˜¯$s,r$å„è‡ªæœ€åˆç†çš„ä¸€ä¸ªå–å€¼ä¸å…¶ä»–çš„åšåŒ¹é…

```python
def multibox_prior(data, sizes, ratios):
    # dataå°±æ˜¯æŒ‡image_tensor
    # æå–å›¾ç‰‡é«˜å®½ 660*524
    in_height, in_width = data.shape[-2:]
    device, num_sizes, num_ratios = data.device, len(sizes), len(ratios)
    boxes_per_pixel = (num_sizes + num_ratios - 1)
    # s
    size_tensor = torch.tensor(sizes, device=device)
    # ratio
    ratio_tensor = torch.tensor(ratios, device=device)
    # ä¸ºäº†å°†é”šç‚¹ç§»åŠ¨åˆ°åƒç´ çš„ä¸­å¿ƒï¼Œéœ€è¦è®¾ç½®åç§»é‡ã€‚
    # å› ä¸ºä¸€ä¸ªåƒç´ çš„çš„é«˜ä¸º1ä¸”å®½ä¸º1ï¼Œæˆ‘ä»¬é€‰æ‹©åç§»æˆ‘ä»¬çš„ä¸­å¿ƒ0.5
    offset_h, offset_w = 0.5, 0.5
    #å®½é«˜ç¼©æ”¾æ­¥é•¿
    steps_h = 1. / in_height
    steps_w = 1. / in_width
    # ç”Ÿæˆé”šæ¡†çš„æ‰€æœ‰ä¸­å¿ƒç‚¹
    center_h = (torch.arange(in_height, device=device) + offset_h) * steps_h
    center_w = (torch.arange(in_width, device=device) + offset_w) * steps_w
    # åˆ›é€ ç½‘æ ¼ (660, 524)
    shift_y, shift_x = torch.meshgrid(center_h, center_w)
    shift_y, shift_x = shift_y.reshape(-1), shift_x.reshape(-1)
    #reshape(-1)=reshape(1,-1)ï¼Œæ¨ªå‘é“ºæ»¡(1, 660*524=345840)

    w = torch.cat((size_tensor * torch.sqrt(ratio_tensor[0]),
                   sizes[0] * torch.sqrt(ratio_tensor[1:]))) \
    * in_height / in_width
    #s*æ ¹å·r*h/w
    #\è¡¨ç¤ºä»£ç æ¢è¡Œ
    h = torch.cat((size_tensor / torch.sqrt(ratio_tensor[0]),
                   sizes[0] / torch.sqrt(ratio_tensor[1:])))
    #s/æ ¹å·r

    anchor_manipulations = torch.stack((-w, -h, w, h)).T.repeat(in_height * in_width, 1) / 2
    #stack()é»˜è®¤æŒ‰è¡Œå †ç§¯ï¼Œcat()é»˜è®¤æŒ‰è¡Œè¿æ¥,4*5
    #T:5*4
    #repeat(): Repeats this tensor along the specified dimensions.
    #ä¼ å…¥(m,n)ï¼Œæ²¿è¡Œèµ‹å€¼h*w,æ²¿åˆ—å¤åˆ¶1
    #èµ‹å€¼heightè¡Œå’Œwidthåˆ—
    #å››ä¸ªç‚¹çš„ç›¸å¯¹åæ ‡å¤åˆ¶åˆ°æ¯ä¸ªåƒç´ ä¸Š
    #(5*660*524=1729200, 4)

    out_grid = torch.stack([shift_x, shift_y, shift_x, shift_y], dim=1).repeat_interleave(boxes_per_pixel, dim=0)
    #dim=1,æŒ‰åˆ—å¹¶åˆ—ï¼Œå› ä¸ºæ˜¯ä¸€ç»´å¼ é‡(345840,4)
    #repeat_interleave()æŒ‰ç…§å…ƒç´ æŒ‰è¡Œå¤åˆ¶5é(1729200, 4)
    #ä¹Ÿå°±æ˜¯æ¯è¡Œå…ˆå¤åˆ¶äº”éï¼Œå†å¤åˆ¶ä¸‹ä¸€è¡Œ5é
    output = out_grid + anchor_manipulations
    return output.unsqueeze(0)
```

<font color=red> æœ‰ä¸¤ä¸ªé—®é¢˜ï¼š

- å®šä¹‰è¾¹æ¡†å®½é«˜çš„ç®—æ³•ï¼Œä»¥åŠ s å’Œ r çš„å®šä¹‰ï¼›
- å›¾ç‰‡çš„å®½é«˜å¿…é¡»æ˜¯äº’è´¨çš„ï¼Œæ‰èƒ½ä¿è¯ x, y åœ¨åˆ†é…çš„æ—¶å€™ä¸é‡å¤ï¼Œè¿™é‡Œçš„æƒ…å†µæ˜¾ç„¶æœ‰é‡å¤ï¼Œå®½é«˜çš„å…¬çº¦æ•°æ˜¯ 4ï¼Œæ‰€ä»¥é‡å¤äº† 4 å€ï¼Œæˆ–è€…è¯´é”šæ¡†å°‘äº† 4 å€ã€‚
  </font>

- æŒ‰åƒç´ åˆ†å—

```
img = d2l.plt.imread('../code/Image/Lions.png')
h, w = img.shape[:2]

print(h, w)
X = torch.rand(size=(1, 3, h, w))
Y = multibox_prior(X, sizes=[0.75, 0.5, 0.25], ratios=[1, 2, 0.5])

Y.shape

boxes = Y.reshape(h, w, 5, 4)
#reshapeçš„æ—¶å€™ä»é«˜ç»´åº¦å…ˆå¼€å§‹ï¼Œå…ˆæŒ‰åˆ—æ‹¿ï¼Œå†æ‹¿ä¸‹ä¸€è¡Œï¼›åŒæ ·ï¼Œå…ˆæŒ‰åˆ—å¡«ï¼Œå†å¡«ä¸‹ä¸€è¡Œæ ¼åˆ—
boxes[250, 250, :, :]
```

<font color=red>
è¿™é‡Œçš„åˆ†å—åªæ˜¯æŠŠ $ 5\times4$ çš„é”šæ¡†åˆ†é…åˆ°æ¯ä¸ªåƒç´ çš„ä½ç½®ï¼Œä½†å¹¶ä¸æ˜¯ä¸åƒç´ ç´¢å¼•å‡†ç¡®æ˜ å°„ï¼Œä¾¿äºè§†å¯Ÿ
</font>

**ç»˜åˆ¶é”šæ¡†**

```
def show_bboxes(axes, bboxes, labels=None, colors=None):
    def _make_list(obj, default_values=None):
        if obj is None:
            obj = default_values
        elif not isinstance(obj, (list, tuple)):
            obj = [obj]
        return obj

    #å†…ç½®å‡½æ•°ç”¨_å¼€å¤´å®šä¹‰è¡¨æ˜
    #è™½ç„¶æˆ‘å¯ä»¥è¢«è®¿é—®ï¼Œä½†æ˜¯ï¼Œè¯·æŠŠæˆ‘è§†ä¸ºç§æœ‰å˜é‡ï¼Œä¸è¦éšæ„è®¿é—®
    labels = _make_list(labels)
    colors = _make_list(colors, ['b', 'g', 'r', 'm', 'c'])
    #è¿”å›colors
    for i, bbox in enumerate(bboxes):
        color = colors[i % len(colors)]
        rect = d2l.bbox_to_rect(bbox.detach().numpy(), color)
        #Convert bounding box to matplotlib format
        axes.add_patch(rect)
        if labels and len(labels) > i:
            text_color = 'k' if color == 'w' else 'w'
            axes.text(rect.xy[0], rect.xy[1], labels[i],
                      va='center', ha='center', fontsize=9, color=text_color,
                      bbox=dict(facecolor=color, lw=0))
            #å†™æ–‡æœ¬æ¡†

d2l.set_figsize()
bbox_scale = torch.tensor((w, h, w, h))
#æŠŠæ¡†æ”¾å¤§
fig = d2l.plt.imshow(img)

show_bboxes(fig.axes, boxes[250, 250, :, :] * bbox_scale,#å–å‡ºå¯¹åº”ç‚¹
            ['s=0.75, r=1', 's=0.5, r=1', 's=0.25, r=1', 's=0.75, r=2',
             's=0.75, r=0.5'])

```

![](\Images/å¾®ä¿¡æˆªå›¾_20211229230829.png)

**æ±‚ IoU**

![](\Images/ç¤ºæ„å›¾.png)

```
def box_iou(boxes1, boxes2):
    box_area = lambda boxes: ((boxes[:, 2] - boxes[:, 0]) *
                              (boxes[:, 3] - boxes[:, 1]))
            #(x2-x1)(y2-y1)
    areas1 = box_area(boxes1)#(5, 1)
    areas2 = box_area(boxes2)#(5, 1)

    inter_upperlefts = torch.max(boxes1[:, None, :2], boxes2[:, :2])
    inter_lowerrights = torch.min(boxes1[:, None, 2:], boxes2[:, 2:])
    #åˆ‡ç‰‡é‡Œçš„Noneç›¸å½“äºåœ¨è¯¥ä½ç½®å¢åŠ ä¸€ä¸ªç»´åº¦
    #åšè¿ç®—è¦åœ¨åŒä¸€ç»´åº¦ä¸Šï¼Œæœ‰é«˜åˆ°ä½
    #ä¹Ÿå°±æ˜¯è¯´ï¼Œboxes1.slice=(5, 1, 2), boxes.slice=(5, 2),
    #ç”¨(1, 2)å’Œ(5, 2)åšå¹¿æ’­ï¼Œå†ç”¨ç¬¬äºŒç»„ï¼Œç›´åˆ°ç¬¬äº”ç»„
    #æœ€ç»ˆå½¢çŠ¶(5, 5, 2)ï¼Œä»£è¡¨ä¸€ä¸ªç‚¹çš„äº”ä¸ªé”šæ¡†ä¸å¦ä¸€ä¸ªç‚¹çš„äº”ä¸ªé”šæ¡†å·¦ä¸Šã€å³ä¸‹çš„æå°ã€æå¤§å€¼

    #äº‹å®ä¸Šï¼Œå›¾ç‰‡åæ ‡yè½´æ˜¯åå‘ï¼Œæ‰€ä»¥å·¦ä¸Šå’Œå³ä¸‹çš„æå°æå¤§æ˜¯å†…æµ‹çš„ç‚¹
    inters = (inter_lowerrights - inter_upperlefts).clamp(min=0)
    #clamp()å®šä¹‰äº†åˆ†æ®µå‡½æ•°ä¸Šä¸‹é™,é˜²æ­¢ä¸¤ä¸ªæ¡†ä¸é‡åˆè€Œå‡ºç°è´Ÿå€¼
    #æ¢è¨€ä¹‹ï¼Œinteræœ¬å°±æ˜¯0
    #shape(5, 5, 2)

    inter_areas = inters[:, :, 0] * inters[:, :, 1]
    #ç®—äº¤é›†(5, 5, 1)
    union_areas = areas1[:, None] + areas2 - inter_areas
    #ç®—å¹¶é›†(5, 1, 1)+(5, 1) - (5, 5, 1)=(5, 5, 1)
    return inter_areas / union_areas
```

![](\Images/clamp.png)

**ç»™è¾¹ç•Œæ¡†åˆ†é…é”šæ¡†**

```
def assign_anchor_to_bbox(ground_truth, anchors, device ,iou_threshold=0.5):
    #ground_truthçœŸå®è¾¹ç•Œæ¡†
    num_anchors, num_gt_boxes = anchors.shape[0], ground_truth.shape[0]
    jaccard = box_iou(anchors, ground_truth)
    #(num_anchors, num_gt_boxes, 1)
    anchors_bbox_map = torch.full((num_anchors,), -1, dtype=torch.long, device= device)
    #torch.full():Creates a tensor of size size filled with fill_value. The tensorâ€™s dtype is inferred from fill_value.
    #(num_anchors,)è¡¨ç¤ºåˆ›å»ºé•¿åº¦ä¸ºnum_anchorsçš„ä¸€ç»´tuple,å¡«å……-1
    max_ious, indices = torch.max(jaccard, dim=1)
    #Returns a namedtuple (values, indices)
    #where values is the maximum value of each row of the input tensor in the given dimension dim.
    #And indices is the index location of each maximum value found (argmax).
    #å½“æŠŠmax()ä½œç”¨äºé«˜ç»´åº¦å¼ é‡æ—¶ï¼Œè¿”å›è¯¥ç»´åº¦çš„çŸ©é˜µæ¯ä¸€è¡Œçš„æœ€å¤§å€¼å’Œç´¢å¼•å€¼
    #ä¹Ÿå°±æ˜¯è¯´è¿™é‡Œè¿”å›æ¯ä¸ªé”šæ¡†å¯¹äºæ‰€æœ‰è¾¹ç•Œæ¡†çš„æœ€å¤§iouå’Œå¯¹åº”çš„è¾¹ç•Œæ¡†æ ‡å·
    #max_ious/indices.shape=(num_anchors, 1)
    anc_i = torch.nonzero(max_ious >= 0.5).reshape(-1)
    #å¯¹äºå¤§äº0.5çš„iou,è¿”å›True
    #nonzero()è¿”å›å¼ é‡éé›¶å€¼çš„ç´¢å¼•ï¼Œæ˜¯ä¸€ä¸ªäºŒç»´å¼ é‡ï¼Œå†…éƒ¨ç»´åº¦å­˜å‚¨ç´¢å¼•
    #reshape(-1)=reshape(1,-1),é“ºå¹³ï¼Œå˜æˆä¸€ç»´
    #ä¹Ÿå°±æ˜¯å„ä¸ªç¬¦åˆè¦æ±‚çš„é”šæ¡†çš„æ ‡å·
    box_j = indices[max_ious >= 0.5]
    #ç”¨boolä½œä¸ºç´¢å¼•ï¼Œè¿”å›Trueæ‰€åœ¨ä½ç½®çš„ç´¢å¼•
    #A= [[1], [2], [3]], B = [[True], [False], [True]],
    #A[B]==[A[0],A[2]]==[[1],[3]]
    #æ­¤å¤„å°±æ˜¯è¿”å›å¤§äº0.5çš„é”šæ¡†çš„ç´¢å¼•

    ##anc_iå’Œ box[j]æ‰¾åˆ°åˆ°è¾¾thresholdçš„é”šæ¡†ä»¥åŠä¸å…¶æ˜ å°„çš„è¾¹ç•Œæ¡†
    anchors_bbox_map[anc_i] = box_j
    #æŠŠnum_anch*[-1]çš„å‘é‡ï¼Œéè´Ÿé”šæ¡†ä½ç½®æ›¿æ¢ä¸ºå¯¹åº”è¾¹ç•Œæ¡†çš„æ ‡å·ï¼Œå…¶ä½™ä¾æ—§ä¸ºè´Ÿç±»
    col_discard = torch.full((num_anchors,), -1)
    #num_anchors*[-1]
    row_discard = torch.full((num_gt_boxes,), -1)
    #num_gt_boxes*[-1]
    for _ in range(num_gt_boxes):
        max_idx = torch.argmax(jaccard)
        #torch.argmaxå¦‚æœä¸æŒ‡å®šç»´åº¦ï¼Œå°±æ‰€æœ‰å…ƒç´ æ’æˆä¸€è¡Œï¼Œå–æœ€å¤§ä½ç½®
        box_idx = (max_idx % num_gt_boxes).long()
        #long()å°†æ•°å­—æˆ–å­—ç¬¦ä¸²è½¬æ¢ä¸ºä¸€ä¸ªé•¿æ•´å‹ ==ã€‹æ‰¾åˆ°æœ€å¤§å€¼æ‰€åœ¨åˆ—ï¼Œå³è¾¹ç•Œæ¡†åºå·
        anc_idx = (max_idx / num_gt_boxes).long()
        #å¯¹äºä¸€ä¸ªfloat,å»å°æ•°éƒ¨åˆ†å–æ•´ ==ã€‹æ‰¾åˆ°æœ€å¤§å€¼æ‰€åœ¨è¡Œï¼Œå³é”šæ¡†åºå·
        anchors_bbox_map[anc_idx] = box_idx #æŠŠé”šæ¡†ä½ç½®çš„ï¼ˆ-1ï¼‰æ¢åšè¾¹ç•Œæ¡†çš„å·
        jaccard[:, box_idx] = col_discard #æŠŠæ‰€åœ¨åˆ—é‡æ–°èµ‹å€¼ä¸ºè´Ÿç±»
        jaccard[anc_idx, :] = row_discard #æŠŠæ‰€åœ¨è¡Œé‡æ–°èµ‹å€¼ä¸ºè´Ÿç±»
    return anchors_bbox_map
    # éå†ç»“æŸ anchors_bbox_map.shape=(num_anchors, 1)ï¼ŒæŸä¸ªgtæ‰€åœ¨è¡Œæ ‡å·ä¸å¯¹åº”gtæ˜ å°„ï¼Œå…¶ä½™ä¸º-1ã€‚
```

<font color=red>
åœ¨ for loop ä¹‹å‰çš„ä»£ç å¹¶æ²¡æœ‰å®é™…ç”¨åˆ°ï¼Œç›¸å½“äºä¸€ç§è¡¥å……ç®—æ³•ï¼Œä¿è¯ç›¸å…³åº¦æœ‰ä¸€ä¸ªé˜ˆå€¼ï¼Œè€Œä¸”äº§ç”Ÿäº†ä¸€ä¸ªbugâ€”â€”å¾ªç¯ä¹‹å‰å¯¹æ‰€æœ‰é”šæ¡†åšäº†é˜ˆå€¼æ˜ å°„ï¼Œä½†åœ¨å¾ªç¯ä¸­é‡æ–°æ˜ å°„çš„æ—¶å€™å‰é¢å·²ç»èµ‹å€¼çš„anchors_bbox_mapæ²¡æœ‰è¢«å®Œå…¨è¦†ç›–ï¼Œæ‰€ä»¥å¯¹äºåŒä¸€ä¸ªè¾¹ç•Œæ¡†ï¼Œæœ‰ä¸æ­¢ä¸€ä¸ªé”šæ¡†çš„æ˜ å°„ã€‚
</font>

å…³äºå¤šç»´åº¦å¼ é‡è®¡ç®—:

![](\Images/é«˜ç»´åº¦å¼ é‡è¿ç®—.png)

**é”šæ¡†ä¸è¾¹ç•Œæ¡†åç§»æ‹Ÿåˆ**

åš Normalizeï¼Œå¹¶ä¸”æ–¹å·®è¾ƒå¤§ï¼Œåˆ†æ•£æ ·æœ¬ï¼Œä¾¿äºè®¡ç®—

å‡è®¾ä¸€ä¸ªé”šæ¡† A è¢«åˆ†é…äº†ä¸€ä¸ªçœŸå®è¾¹ç•Œæ¡† B ã€‚ ä¸€æ–¹é¢ï¼Œé”šæ¡† A çš„ç±»åˆ«å°†è¢«æ ‡è®°ä¸ºä¸ B ç›¸åŒã€‚ å¦ä¸€æ–¹é¢ï¼Œé”šæ¡† A çš„åç§»é‡å°†æ ¹æ® B å’Œ A ä¸­å¿ƒåæ ‡çš„ç›¸å¯¹ä½ç½®ä»¥åŠè¿™ä¸¤ä¸ªæ¡†çš„ç›¸å¯¹å¤§å°è¿›è¡Œæ ‡è®°ã€‚ é‰´äºæ•°æ®é›†å†…ä¸åŒçš„æ¡†çš„ä½ç½®å’Œå¤§å°ä¸åŒï¼Œæˆ‘ä»¬å¯ä»¥å¯¹é‚£äº›ç›¸å¯¹ä½ç½®å’Œå¤§å°åº”ç”¨å˜æ¢ï¼Œä½¿å…¶è·å¾—åˆ†å¸ƒæ›´å‡åŒ€ä¸”æ˜“äºæ‹Ÿåˆçš„åç§»é‡ã€‚ç»™å®šæ¡† A å’Œ B ï¼Œä¸­å¿ƒåæ ‡åˆ†åˆ«ä¸º $(x_a,y_a)$ å’Œ $(x_b,y_b)$ ï¼Œå®½åº¦åˆ†åˆ«ä¸º $w_a$ å’Œ $w_b$ ï¼Œé«˜åº¦åˆ†åˆ«ä¸º $h_a$ å’Œ $h_b$ ã€‚ æˆ‘ä»¬å¯ä»¥å°† A çš„åç§»é‡æ ‡è®°ä¸º:

$$\left({{x_b-x_a\over w_a}-\mu_x\over \sigma_x},{{y_b-y_a\over h_a}-\mu_y\over \sigma_y},{\log{w_b\over w_a}-\mu_w\over\sigma_w},{\log{h_b\over h_a}-\mu_h\over\sigma_h}\right)$$

é€šå¸¸
$\mu_x=\mu_y=\mu_w=\mu_h=0$
$\sigma_x=\sigma_y=0.1,\ \sigma_w=\sigma_h=0.2$

```
#anchors.shape=(num_anchors=num_gt, 4)
def offset_boxes(anchors, assigned_bb, eps=1e-6):
   c_anc = d2l.box_corner_to_center(anchors)
   #ä¸­å¿ƒæ³•è¡¨ç¤ºé”šæ¡†å››ç»´
   c_assigned_bb = d2l.box_corner_to_center(assigned_bb)
   #ä¸­å¿ƒæ³•è¡¨ç¤ºæ˜ å°„è¾¹ç•Œæ¡†å››ç»´
   offset_xy = 10 * (c_assigned_bb[:, :2] - c_anc[:, :2]) / c_anc[:, 2:]
   ##åç§»è®¡ç®— /sigma=0.1=> *10
   offset_wh = 5 * torch.log(eps + c_assigned_bb[:, 2:] / c_anc[:, 2:])
   ## /sigma=0.2 => *5
   offset = torch.cat([offset_xy, offset_wh], axis=1)
   ##cat()æŒ‰ç»´åº¦è¿æ¥ï¼Œä¹Ÿå°±æ˜¯åœ¨è¯¥ç»´åº¦ä¸Šåšå‡ºæ”¹å˜ã€‚
   ##axiså’Œdimå¯ä»¥äº’æ¢
   ##off_set.shape=(num_gt, 4)
   return offset

def multibox_target(anchors, labels):
   #labels=è¾¹ç•Œæ¡†æ ‡å·
   batch_size, anchors = labels.shape[0], anchors.squeeze(0)
   #labels.shape[0]å°±æ˜¯ä¸€æ¬¡ä¼ å…¥çš„æ–‡ä»¶æ‰¹é‡ï¼Œå¦‚æœæ²¡æœ‰å¤šä½™ï¼ˆä¸º1ï¼‰ç»´åº¦ï¼Œå°±è¿”å›æœ¬èº«
   #squeeze(0)é™ä½ç»´åº¦
   batch_offset, batch_mask, batch_class_labels = [], [], []
   device, num_anchors = anchors.device, anchors.shape[0]

   for i in range(batch_size):
       label = labels[i, :, :]
       #è¿”å›æ ‡å·ï¼ˆç‰©ä½“æ•°é‡ï¼‰ï¼Œæˆ–è€…è¯´è¾¹ç•Œæ¡†çš„æ•°é‡å’Œå››ç»´
       anchors_bbox_map = assign_anchor_to_bbox(
           label[:, 1:], anchors, device)
       #ç¬¬ä¸€ä¸ªç‰¹å¾æ˜¯ç‰©ä½“ç±»åˆ«ï¼Œå¹¶ä¸éœ€è¦ï¼Œæ‰€ä»¥åªå–å‡ºå››ç»´
       #æ±‚å‡ºä¸é”šæ¡†çš„æ˜ å°„
       bbox_mask = ((anchors_bbox_map >= 0).float().unsqueeze(-1)).repeat(
           1, 4)
       #æ±‚å‡ºæ­£ç±»ï¼Œå†æŠŠboolè½¬åŒ–ä¸ºæµ®ç‚¹æ•°(0., 1.),shape=(num_anchors, 1)
       #å†æ²¿åˆ—å¤åˆ¶ï¼Œshape(num_anchors, 4)
       class_labels = torch.zeros(num_anchors, dtype=torch.long,
                                  device=device)
       #num_anchors*(0)å‘é‡
       assigned_bb = torch.zeros((num_anchors, 4), dtype=torch.float32,
                                 device=device)
       #(num_anchors,4) * 0äºŒç»´å¼ é‡
       indices_true = torch.nonzero(anchors_bbox_map >= 0)
       #è¿”å›æ­£ç±»åœ¨anchorså‘é‡é‡Œçš„ç´¢å¼•
       bb_idx = anchors_bbox_map[indices_true]
       #æŠŠæ­£ç±»ç´¢å¼•çš„å€¼æå–å‡ºæ¥ï¼Œä¹Ÿå°±æ˜¯æ‰€æ˜ å°„çœŸå®è¾¹ç•Œæ¡†çš„æ ‡å·
       class_labels[indices_true] = label[bb_idx, 0].long() + 1
       #å‰é¢å®šä¹‰çš„å…¨0å‘é‡,æŠŠè¢«æ˜ å°„è¾¹ç•Œæ¡†å¯¹åº”ç‰©ä½“ç±»å‹(åˆ‡ç‰‡[0]) + 1èµ‹å€¼ç»™å®ƒï¼Œåœ¨æ‰“å°çš„æ—¶å€™ä¸è‡³äºå‡ºç°ç¬¬0ç±»ã€‚
       assigned_bb[indices_true] = label[bb_idx, 1:]
       #æŠŠæ˜ å°„gtçš„4ç»´æ˜ å°„ç»™é”šæ¡†

       offset = offset_boxes(anchors, assigned_bb) * bbox_mask
       #æ±‚å‡ºåç§»ï¼ŒæŠŠè´Ÿç±»çš„åç§»å€¼å…¨éƒ¨æ¸…é›¶
       batch_offset.append(offset.reshape(-1))
       #reshape(-1)=reshape(1,-1),é“ºå¹³ï¼Œå˜æˆä¸€ç»´, 4*num_anchorså‘é‡
       #åœ¨åˆ—è¡¨é‡ŒåŠ å¼ é‡
       batch_mask.append(bbox_mask.reshape(-1))
       #reshape(-1)=reshape(1,-1),é“ºå¹³ï¼Œå˜æˆä¸€ç»´, 4*num_anchorså‘é‡ï¼Œæœ‰æ˜ å°„ä¸º4*1ï¼Œæ— æ˜ å°„ä¸º4*0
       batch_class_labels.append(class_labels)
       #num_anchorsé•¿åº¦å‘é‡ï¼Œæœ‰æ˜ å°„ç´¢å¼•ä¸ºç‰©ä½“ç±»å‹+1ï¼Œå…¶ä½™ä¸º0
   bbox_offset = torch.stack(batch_offset)
   # æŠŠåŸåˆ—è¡¨batch_offsetå˜æˆ(batch_size, 4*num_anchors)çš„äºŒç»´å¼ é‡bbox_offset
   bbox_mask = torch.stack(batch_mask)
   # æŠŠåŸåˆ—è¡¨batch_maskå˜æˆ(batch_size, 4*num_anchors)çš„äºŒç»´å¼ é‡bbox_maskï¼Œæœ‰æ˜ å°„ä¸º4*1ï¼Œæ— æ˜ å°„ä¸º4*0
   class_labels = torch.stack(batch_class_labels)
   #æŠŠåŸåˆ—è¡¨batch_class_labelså˜æˆ(batch_size, num_anchors)çš„äºŒç»´å¼ é‡class_labelsï¼Œæœ‰æ˜ å°„ç´¢å¼•ä¸ºç‰©ä½“ç±»å‹+1ï¼Œå…¶ä½™ä¸º0
   return (bbox_offset, bbox_mask, class_labels)
   # stack()å¯ä»¥æŠŠåˆ—è¡¨/å…ƒç»„é‡Œçš„å¼ é‡å…ƒç´ æ²¿ä¸€ä¸ªç»´åº¦åˆå¹¶æˆä¸€ä¸ªå¼ é‡
```

**æ —å­**

```
ground_truth = torch.tensor([[0, 0.1, 0.08, 0.52, 0.92],
                         [1, 0.55, 0.2, 0.9, 0.88]])
anchors = torch.tensor([[0, 0.1, 0.2, 0.3], [0.15, 0.2, 0.4, 0.4],
                    [0.63, 0.05, 0.88, 0.98], [0.66, 0.45, 0.8, 0.8],
                    [0.57, 0.3, 0.92, 0.9]])

fig = d2l.plt.imshow(img)
show_bboxes(fig.axes, ground_truth[:, 1:] * bbox_scale, ['dog', 'cat'], 'k')
show_bboxes(fig.axes, anchors * bbox_scale, ['0', '1', '2', '3', '4']);
labels = multibox_target(anchors.unsqueeze(dim=0),
                         ground_truth.unsqueeze(dim=0))
#unsqueeze(dim=0)è¡¨ç¤ºæ·»åŠ ä¸€ä¸ªç»´åº¦æ‰¹é‡å¤§å°ï¼Œå› ä¸ºåªä¼ äº†ä¸€å¼ å›¾ï¼Œæ‰€ä»¥æ˜¯1
#å¯¹åº”å‡½æ•°é‡Œçš„anchors.squeeze(0)
#è¿”å›é•¿åº¦ä¸ºbbox_offset=20ï¼Œ
labels[2], labels[0]
```

![](/Images/æ —å­.png)

**ç”¨æœ€å¤§æŠ‘åˆ¶åŒ–ç®€**

```
#æ ¹æ®é¢„æµ‹å€¼é€†æ±‚è¾¹ç•Œæ¡†ä½ç½®
def offset_inverse(anchors, offset_preds):

    anc = d2l.box_corner_to_center(anchors)
    #å˜æˆä¸­å¿ƒ4ç»´
    pred_bbox_xy = (offset_preds[:, :2] * anc[:, 2:] / 10) + anc[:, :2]
    pred_bbox_wh = torch.exp(offset_preds[:, 2:] / 5) * anc[:, 2:]
    pred_bbox = torch.cat((pred_bbox_xy, pred_bbox_wh), axis=1)
    predicted_bbox = d2l.box_center_to_corner(pred_bbox)
    #è¿”å›é¢„æµ‹çš„è¾¹ç•Œæ¡†ä½ç½®
    #shape=(num_boxes, 4)
    return predicted_bbox
```

```
#æœ€å¤§æŠ‘åˆ¶ç­›é€‰å‡½æ•°
def nms(boxes, scores, iou_threshold):
    #socresæ˜¯é¢„æµ‹è¯¥é”šæ¡†å±äºæŸä¸ªè¾¹ç•Œæ¡†çš„ç½®ä¿¡åº¦

    B = torch.argsort(scores, dim=-1, descending=True)
    #argsort()å¯¹äºå¼ é‡å…ƒç´ æ’åºï¼Œè¿”å›ç´¢å¼•æ’åºï¼Œé»˜è®¤ä»ä½åˆ°é«˜ï¼Œ descending_default=True
    keep = []
    while B.numel() > 0:
        i = B[0]
        keep.append(i)
        if B.numel() == 1: break
        iou = box_iou(boxes[i, :].reshape(-1, 4), #å˜æˆè¡Œå‘é‡
                      boxes[B[1:], :].reshape(-1, 4)).reshape(-1)#å˜æˆè¡Œå‘é‡len=(num_boxes-1)
        inds = torch.nonzero(iou <= iou_threshold).reshape(-1)#æŠŠé‡å åº¦å°äºé˜ˆå€¼çš„ç´¢å¼•æ‹¿å‡ºæ¥
        B = B[inds + 1]#å› ä¸ºæ‹¿å‡ºå»çš„ç´¢å¼•ä¸åŒ…å«B[0]
    return torch.tensor(keep, device=boxes.device) #è¿”å›ä¸å…¶ä»–éƒ½ä¸é‡åˆçš„boxesçš„ç´¢å¼•
```

```
#æœ€å¤§æŠ‘åˆ¶åº”ç”¨å‡½æ•°

def multibox_detection(cls_probs, offset_preds, anchors, nms_threshold=0.5,
                       pos_threshold=0.009999999):
    #cls_probsä¼ å…¥(batch_size, labels, scores)
    #offset_predsåç§»é¢„æµ‹ç»“æœ
    device, batch_size = cls_probs.device, cls_probs.shape[0]
    anchors = anchors.squeeze(0) #åŠ å…¥é€šé“é¡¹
    num_classes, num_anchors = cls_probs.shape[1], cls_probs.shape[2]
    #num_classesç±»åˆ«æ•°=è¾¹ç•Œæ¡†æ•°ï¼Œnum_anchorsæ¯ä¸ªç‰©ä½“çš„è¾¹ç•Œæ¡†æ•°
    out = []
    for i in range(batch_size):
        cls_prob, offset_pred = cls_probs[i], offset_preds[i].reshape(-1, 4)
        #æ¯å¼ å›¾çš„é¢„æµ‹(labels, boxes, 4d)

        conf, class_id = torch.max(cls_prob[1:], 0) #dim=0
        #æ¯ä¸ªé”šæ¡†å¯¹äºæ¯ä¸ªç±»åˆ«çš„æœ€å¤§é¢„æµ‹ï¼Œä»¥åŠå¯¹åº”ç±»åˆ«çš„index

        predicted_bb = offset_inverse(anchors, offset_pred)
        #è¿”å›è¾¹ç•Œæ¡†å››ç»´
        keep = nms(predicted_bb, conf, nms_threshold)
        #å¾—åˆ°è¿˜æœ‰ç”¨çš„é”šæ¡†


        all_idx = torch.arange(num_anchors, dtype=torch.long, device=device)
        combined = torch.cat((keep, all_idx))
        #è¿æ¥æœ‰ç”¨å’Œæ‰€æœ‰
        uniques, counts = combined.unique(return_counts=True)
        #è¿”å›batchsizeé•¿åº¦å‘é‡ï¼Œä»¥åŠæ¯ä¸ªboxå‡ºç°çš„æ¬¡æ•°
        non_keep = uniques[counts == 1]
        #æŠŠåªå‡ºç°ä¸€æ¬¡çš„é”šæ¡†ç¼–å·æ‹¿å‡ºæ¥
        all_id_sorted = torch.cat((keep, non_keep))
        #æŠŠæœ‰ç”¨çš„å’Œæ²¡ç”¨çš„è¿æ¥
        class_id[non_keep] = -1
        #æŠŠæ²¡ç”¨çš„æ ‡è®°æˆè´Ÿç±»
        #æŠŠç´¢å¼•çš„æ ‡å·åšæˆtensorï¼Œå¯ä»¥æŒ‰é¡ºåºæå–å¯¹åº”å…ƒç´ ç»„æˆæ–°çš„tensor
        class_id = class_id[all_id_sorted]
        #å†æŒ‰ç…§æœ‰ç”¨çš„é¡ºåºæ’åˆ—ï¼ŒæŠŠè´Ÿç±»æ”¾åœ¨æœ€å
        conf, predicted_bb = conf[all_id_sorted], predicted_bb[all_id_sorted]
        #æŠŠè¿™ä¸¤ä¸ªä¹ŸæŒ‰é¡ºåºæ’
        below_min_idx = (conf < pos_threshold)
        #pos_thresholdæ˜¯èƒŒæ™¯ç±»çš„é˜ˆå€¼
        class_id[below_min_idx] = -1
        #boolä½œä¸ºç´¢å¼•ï¼Œå°±æ˜¯ç´¢å¼•Trueçš„ä½ç½®ï¼ŒFalseå°±å¿½ç•¥
        #æŠŠèƒŒæ™¯ç±»ä¹Ÿæ ‡è®°æˆ-1
        conf[below_min_idx] = 1 - conf[below_min_idx]
        pred_info = torch.cat((class_id.unsqueeze(1),
                               conf.unsqueeze(1),
                               predicted_bb), dim=1)
        #æŒ‰åˆ—è¿æ¥ï¼Œ[ç±»åˆ«ï¼Œç½®ä¿¡ç‡ï¼Œè¾¹ç•Œæ¡†å››ç»´]
        out.append(pred_info)
    return torch.stack(out)
```

**å†ä¸€ä¸ªæ —å­**
<font color=red>æˆ‘ä¸å¤ªç†è§£ cls_probs ç¬¬ä¸€è¡Œå…¨é›¶ä»£è¡¨ä»€ä¹ˆ</font>

```
anchors = torch.tensor([[0.1, 0.08, 0.52, 0.92], [0.08, 0.2, 0.56, 0.95],
                      [0.15, 0.3, 0.62, 0.91], [0.55, 0.2, 0.9, 0.88]])
offset_preds = torch.tensor([0] * anchors.numel())
cls_probs = torch.tensor([[0] * 4,
                      [0.9, 0.8, 0.7, 0.1],
                      [0.1, 0.2, 0.3, 0.9]])

fig = d2l.plt.imshow(img)
show_bboxes(fig.axes, anchors * bbox_scale,
            ['dog=0.9', 'dog=0.8', 'dog=0.7', 'cat=0.9'])

output = multibox_detection(cls_probs.unsqueeze(dim=0),
                            offset_preds.unsqueeze(dim=0),
                            anchors.unsqueeze(dim=0),
                            nms_threshold=0.5)
output

fig = d2l.plt.imshow(img)
for i in output[0].detach().numpy():
    if i[0] == -1:
        continue
    #å¿½ç•¥è´Ÿç±»
    label = ('dog=', 'cat=')[int(i[0])] + str(i[1])
    #ç±»åˆ«+ç½®ä¿¡ç‡
    show_bboxes(fig.axes, [torch.tensor(i[2:]) * bbox_scale], label)
```

![](Images/è¾¹ç•Œæ¡†é¢„æµ‹.png)


## Python æ¨¡å—å‚è€ƒæ–‡æ¡£

- `torch.meshgrid` Pytorchç”Ÿæˆç½‘æ ¼æ–¹æ³• ğŸ§[ä¸­æ–‡](https://www.osgeo.cn/matplotlib/api/_as_gen/matplotlib.axes.Axes.add_patch.html) | [å®˜æ–¹è‹±æ–‡](https://pytorch.org/docs/stable/generated/torch.meshgrid.html?highlight=meshgrid)