# 39 - æ ·å¼è¿ç§»

---

### ğŸ¦ æœ¬èŠ‚è¯¾ç¨‹è§†é¢‘åœ°å€ ğŸ‘‰
[![Bilibil](https://i2.hdslb.com/bfs/archive/be5a425d39483a2af5950792d4c9a1a1753a81ea.jpg@640w_400h_100Q_1c.webp)](https://www.bilibili.com/video/BV1Eh41167GN)
## æ ·å¼è¿ç§»(Style Transfer)

é€šä¿—åœ°è¯´å«æ»¤é•œ

![](\Images/039-01.gif)

**åŸºäºCNNçš„æ ·å¼è¿ç§»**

ä¸‰ä¸ªå¹³è¡Œçš„ç¥ç»ç½‘ç»œï¼ˆæˆ–è€…è¯´å¤åˆ¶å‡ºä¸‰ä¸ªç›¸åŒçš„ï¼‰ï¼Œä¸€ä¸ªä»£è¡¨å†…å®¹ï¼ˆåŸå›¾ï¼‰ï¼Œä¸€ä¸ªä»£è¡¨é£æ ¼ï¼ˆæ‹Ÿåˆç›®æ ‡ï¼‰ï¼Œä¸€ä¸ªæ˜¯è®­ç»ƒï¼ˆæŠŠé£æ ¼è¿ç§»åˆ°åŸå›¾ä¸Šï¼‰

åœ¨è®­ç»ƒæ—¶ï¼Œä½¿å†…å®¹å’Œé£æ ¼è®­ç»ƒå‡ºçš„ç‰¹å¾åœ¨æŸäº›å±‚ä¸Šå¯ä»¥å’Œè¿ç§»çš„è®­ç»ƒç‰¹å¾ç›¸åŒ¹é…ï¼Œå¸Œæœ›å™ªéŸ³è¶³å¤Ÿä½ã€‚

è®­ç»ƒç›®æ ‡ä¸æ˜¯å·ç§¯ç½‘ç»œçš„æƒé‡ï¼Œè€Œæ˜¯æœ€ç»ˆçš„é£æ ¼å›¾ã€‚

![](\Images/039-02.png)

### ä»£ç å®ç°

**å‡†å¤‡å·¥ä½œ**

```
%matplotlib inline
import torch
import torchvision
from torch import nn
from d2l import torch as d2l

d2l.set_figsize()
content_img = d2l.Image.open('../data/test_img.jpg')
d2l.plt.imshow(content_img);
```

```
rgb_mean = torch.tensor([0.485, 0.456, 0.406])
rgb_std = torch.tensor([0.229, 0.224, 0.225])

def preprocess(img, image_shape):
    transforms = torchvision.transforms.Compose([
        torchvision.transforms.Resize(image_shape),
        torchvision.transforms.ToTensor(),
        torchvision.transforms.Normalize(mean=rgb_mean, std=rgb_std)])
    return transforms(img).unsqueeze(0)
#ToTensor()
#å°†å…¶å…ˆç”±HWCè½¬ç½®ä¸ºCHWæ ¼å¼ï¼Œå†è½¬ä¸ºfloatåæ¯ä¸ªåƒç´ é™¤ä»¥255
#Converts a PIL Image or numpy.ndarray (H x W x C) in the range [0, 255] to a torch.FloatTensor of shape (C x H x W) in the range [0.0, 1.0]
#æŠŠæ¯ä¸ªåƒç´ çš„RGBå€¼æ”¾ç¼©åˆ°0-1çš„åŒºé—´å†…ï¼Œæ–¹ä¾¿è®¡ç®—
#mean/stdçš„ä¸¤ç»„å€¼æ˜¯åœ¨ImageNetä¸Šå–å‡ºæ¥çš„ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨è®­ç»ƒæ—¶åˆå§‹åŒ–çš„æ–¹å¼
def postprocess(img):
    img = img[0].to(rgb_std.device)
    img = torch.clamp(img.permute(1, 2, 0) * rgb_std + rgb_mean, 0, 1)
    #é™åˆ¶åœ¨0-1ä¹‹é—´
    return torchvision.transforms.ToPILImage()(img.permute(2, 0, 1))

## æ¨¡å‹ä¸‹è½½
pretrained_net = torchvision.models.vgg19(pretrained=True)
```

**æŠ½å–ç‰¹å¾**

æ¨¡å‹æœ¬èº«ä¸éœ€è¦è®­ç»ƒï¼Œæ‰€ä»¥ç‰¹å¾å¯ä»¥é€šè¿‡é¢„è®­ç»ƒçš„æ¨¡å‹ç›´æ¥æŠ½å–ã€‚

```
style_layers, content_layers = [0, 5, 10, 19, 28], [25]

net = nn.Sequential(*[pretrained_net.features[i] for i in
                      range(max(content_layers + style_layers) + 1)])
    #è¿™é‡Œæ˜¯ä¸¤ä¸ªåˆ—è¡¨ç›¸åŠ ï¼Œ+1æ˜¯å–å¼€åŒºé—´

def extract_features(X, content_layers, style_layers):
    contents = []
    styles = []
    for i in range(len(net)):
        X = net[i](X)
        #å¯¹è¾“å…¥æŒ‰å±‚è¿ç®—
        if i in style_layers:
            #å½“åœ¨é£æ ¼å¯¹åº”å±‚æå–ç‰¹å¾
            styles.append(X)
        if i in content_layers:
            #å½“åœ¨å†…å®¹å¯¹åº”å±‚æå–ç‰¹å¾
            contents.append(X)
    return contents, styles

def get_contents(image_shape, device):
    content_X = preprocess(content_img, image_shape).to(device)
    contents_Y, _ = extract_features(content_X, content_layers, style_layers)
    return content_X, contents_Y
    # æŠ½å–å†…å®¹
def get_styles(image_shape, device):
    style_X = preprocess(style_img, image_shape).to(device)
    _, styles_Y = extract_features(style_X, content_layers, style_layers)
    return style_X, styles_Y
    # æŠ½å–æ ·å¼

#å› ä¸ºç½‘ç»œä¸éœ€è¦åå¤è®­ç»ƒï¼Œæ‰€ä»¥åªæŠ½å–ä¸€æ¬¡æˆç†Ÿç‰¹å¾ï¼Œå°±å¯ä»¥æœ‰è¶³å¤Ÿä»£è¡¨æ€§äº†
```
**å®šä¹‰æŸå¤±å‡½æ•°**

```
def content_loss(Y_hat, Y):
    #å†…å®¹æŸå¤±ç”¨å‡æ–¹è¯¯å·®
    return torch.square(Y_hat - Y.detach()).mean()
```
- æ ¼æ‹‰å§†çŸ©é˜µ

ä¸ºè®¡ç®—é£æ ¼æŸå¤±ï¼Œéœ€è¦é€šé“ä¹‹é—´çš„ç»Ÿè®¡ç‰¹å¾ã€‚æŠŠè¾“å…¥ $\bf X$ è½¬æ¢ä¸º $(c,hw)$ çš„çŸ©é˜µï¼Œæ¯è¡Œå°±ä»£è¡¨ä¸€ä¸ªé€šé“ã€‚

${\bf XX^T}\in\mathbb R^{c\times c}$ä¸­ï¼Œ$i$ è¡Œ $j$ åˆ—çš„å…ƒç´  $x_{ij}$ å°±æ˜¯é€šé“ $i$ å’Œ $j$ å‘é‡çš„å†…ç§¯ï¼Œä»£è¡¨äº†ä¸¤è€…åœ¨é£æ ¼ç‰¹å¾ä¸Šçš„ç›¸å…³æ€§ã€‚å¦‚æœ $hw$ è¾ƒå¤§ï¼Œä¼šä½¿å…ƒç´ å€¼è¿‡å¤§ï¼Œæ‰€ä»¥éœ€è¦é™¤ä»¥çŸ©é˜µä¸­çš„å…ƒç´ ä¸ªæ•° $chw$ normalizeã€‚

```
def gram(X):
    #é€šé“å†…éƒ¨çš„ç»Ÿè®¡ä¿¡æ¯å’Œé€šé“ä¹‹é—´çš„ç»Ÿè®¡ä¿¡æ¯
    #ä¸€é˜¶ç»Ÿè®¡å‡å€¼ï¼ŒäºŒé˜¶ç»Ÿè®¡åæ–¹å·®
    num_channels, n = X.shape[1], X.numel() // X.shape[1]
    X = X.reshape((num_channels, n))
    return torch.matmul(X, X.T) / (num_channels * n)

def style_loss(Y_hat, gram_Y):
    return torch.square(gram(Y_hat) - gram_Y.detach()).mean()
    #åˆæˆå›¾åƒä¸é£æ ¼å›¾åƒåœ¨é£æ ¼å±‚çš„è¾“å‡º
    #style_layers=[0, 5, 10, 19, 28]
```
- å…¨å˜åˆ†æŸå¤±

æˆ‘ä»¬å­¦åˆ°çš„åˆæˆå›¾åƒé‡Œé¢æœ‰å¤§é‡é«˜é¢‘å™ªç‚¹ï¼Œå³æœ‰ç‰¹åˆ«äº®æˆ–è€…ç‰¹åˆ«æš—çš„é¢—ç²’åƒç´ ã€‚ å®šä¹‰å…¨å˜åˆ†æŸå¤±ï¼š

$\sum_{i,j}|x_{i,j}-x_{i+1,j}|+|x_{i,j}-x_{i,j+1}|$

ç»Ÿè®¡æ¯ä¸ªå…ƒç´ å’Œå…¶ç›¸é‚»è¡Œã€åˆ—çš„è¯¯å·®ç»å¯¹å€¼

```
def tv_loss(Y_hat):
    #é™å™ªçš„å¸¸ç”¨æ–¹æ³•
    return 0.5 * (torch.abs(Y_hat[:, :, 1:, :] - Y_hat[:, :, :-1, :]).mean() +
                  torch.abs(Y_hat[:, :, :, 1:] - Y_hat[:, :, :, :-1]).mean())
    #è¯•çœ‹å¦‚ä½•ç”¨åˆ‡ç‰‡å–ä»£å¾ªç¯
```

```
content_weight, style_weight, tv_weight = 1, 1e3, 10

def compute_loss(X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram):
    # åˆ†åˆ«è®¡ç®—å†…å®¹æŸå¤±ã€é£æ ¼æŸå¤±å’Œå…¨å˜åˆ†æŸå¤±
    contents_l = [content_loss(Y_hat, Y) * content_weight for Y_hat, Y in zip(
        contents_Y_hat, contents_Y)]
    styles_l = [style_loss(Y_hat, Y) * style_weight for Y_hat, Y in zip(
        styles_Y_hat, styles_Y_gram)]
    tv_l = tv_loss(X) * tv_weight
    # å¯¹æ‰€æœ‰æŸå¤±åŠ æƒæ±‚å’Œ
    l = sum(10 * styles_l + contents_l + [tv_l])
    return contents_l, styles_l, tv_l, l
```
**åˆå§‹åŒ–å›¾åƒ**

åœ¨é£æ ¼è¿ç§»ä¸­ï¼Œåˆæˆçš„å›¾åƒï¼ˆé‡Œçš„åƒç´ ï¼‰æ˜¯è®­ç»ƒæœŸé—´å”¯ä¸€éœ€è¦æ›´æ–°çš„å˜é‡ã€‚

```
class SynthesizedImage(nn.Module):
    def __init__(self, img_shape, **kwargs):
        super(SynthesizedImage, self).__init__(**kwargs)
        self.weight = nn.Parameter(torch.rand(*img_shape))

    def forward(self):
        return self.weight

def get_inits(X, device, lr, styles_Y):
    gen_img = SynthesizedImage(X.shape).to(device)
    gen_img.weight.data.copy_(X.data)
    #æœ€å¼€å§‹å®Œå…¨ç”¨Xçš„å†…å®¹
    trainer = torch.optim.Adam(gen_img.parameters(), lr=lr)
    styles_Y_gram = [gram(Y) for Y in styles_Y]
    #æ¯ä¸€å±‚çš„é£æ ¼æŸå¤±
    return gen_img(), styles_Y_gram, trainer
```
**è®­ç»ƒå‡½æ•°**

```
def train(X, contents_Y, styles_Y, device, lr, num_epochs, lr_decay_epoch):
    X, styles_Y_gram, trainer = get_inits(X, device, lr, styles_Y)
    scheduler = torch.optim.lr_scheduler.StepLR(trainer, lr_decay_epoch, 0.8)
    animator = d2l.Animator(xlabel='epoch', ylabel='loss',
                            xlim=[10, num_epochs],
                            legend=['content', 'style', 'TV'],
                            ncols=2, figsize=(7, 2.5))
    for epoch in range(num_epochs):
        trainer.zero_grad()
        contents_Y_hat, styles_Y_hat = extract_features(
            X, content_layers, style_layers)
        contents_l, styles_l, tv_l, l = compute_loss(
            X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram)
        l.backward()
        trainer.step()
        scheduler.step()
        if (epoch + 1) % 10 == 0:
            animator.axes[1].imshow(postprocess(X))
            animator.add(epoch + 1, [float(sum(contents_l)),
                                     float(sum(styles_l)), float(tv_l)])
    return X
```